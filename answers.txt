49. Операционные системы: подходы к определению операционной системы как вида программного обеспечения,
функции операционных систем, архитектурные типы, современные тенденции в развитии операционных систем.
==============================================================================================================

__Операционная система__ - вид программного обеспечения, управляющего работой вычислительной системы, а также
расширяющего возможности ЭВМ.

ПОДХОДЫ
1) ОС как расширенная машина.

ОС предоставляет сервисы приложениям пользовательского уровня:
    - Системные вызовы.
    Системные вызовы - это, по сути, механизм, с помощью которого пользовательские приложения запрашивают
    выполнение некоторого действия от ОС. Типичными примерами системных вызовов являются порождение дочернего процесса,
    открытие/закрытие нового файла, запись/чтение в/из файл(а).
    - Абстракции (файлы, сокеты) для доступа к устройствам ввода/вывода.
    Ключевой особенностью является единообразие интерфейса независимо от конкретного оборудования
    (сетевая карта, жёсткий диск). В данном случая ядро (kernel) операционной системы преобразует
    системные вызовы в обращения к конкретным драйверам периферийного оборудования. За счёт этого
    упрощается разработка программного обеспечения.
    - Виртуализация. Концепция "процесса" как программы, исполняющейся на виртуальном процессоре, позволяет предоставить программе
    видение, будто она единолично исполняется на процессоре и в её распоряжении находится всё оперативная память.
    Здесь важно отметить, что без аппаратной поддержки (MMU, прерывания) данные возможности не были бы доступны.
Таким образом, ОС расширяет возможности компьютера, является как бы "новым уровнем" в архитектуре компьютера.

2) ОС как менеджер ресурсов.

В данном подходе считается, что основная задача ОС - упорядоченное и управляемое распределение ресурсов:
    процессора;
    оперативной памяти;
    устройств ввода-вывода
-- между различными программами, претендующими на их использования.

Функции операционных систем:

1) Распределение ресурсов программам -- "процессам": процессорное время, память, устройства ввода/вывода.
2) Управление устройствами компьютера: обслуживание прерываний, конфигурирование оборудование (plug & play).
3) Предоставление сервиса пользовательским приложениям -- выполнение системных вызовов.
4) Виртуализация -- поддержка виртуализации (примеры: VirtualBox, Qemu/KVM)
5) Безопасность -- управление доступом, системы разграничения доступа пользователей, уровни привилегий.
6) Упрощение разработки программного обеспечения -- предоставление библиотек (shared objects), упрощение загрузки программ, облегчение переносимости кода.

Архитектурные типы ("Зоопарк"):

* ОС мейнфреймов
* ОС серверов
* ОС персональных компьютеров
* ОС встраиваемых систем
* ОС реального времени

Тенденции:

* Поддержка большего числа архитектур CPU.
* Поддержка большего количества периферийных устройств.
* Оптимизация кода: внедрение большого числа микро- и архитектурно-зависимых оптимизаций.
* Сохранение обратной совместимости с пользовательским ПО (сохранение бинарного интерфейса системных вызовов).
* Hardening (усиление безопасности, фикс уязвимостей, внедрение новых мер безопасности).
* Сетевые возможности: поддержка многих сетевых карт, реализация известных сетевых протоколов канального, сетевого, транспортного уровней, добавление
  новых возможностей по конфигурированию сети (пример, nl80211 -- конфигурирование Wi-Fi, netlink -- замена интерфейса ioctl'ов для сетевых модулей).
* Поддержка аппаратной виртуализации (KVM -- поддержка Intel VT-x).

################################################################################

50. Управление процессами и потоками: представление процессов и потоков в операционных системах, дисциплины планирования процессов, взаимодействие процессов, проблема тупиков.

__Процесс__ - абстракция, описывающая исполняемую на компьютере программу. Процесс является единицей управления ресурсами: иными словами, ОС планирует ресурсы ЭВМ на уровне процессов
(за исключением, CPU). Каждый процесс характеризуется своей собственной виртуальной памятью, а также своими ресурсами ввода/вывода (открытые файлы, используемые сокеты).
__Поток__ - исполняемая единица. Любой поток принадлежит некоторому процессу, исполняется в его контексте. При этом каждый процесс может иметь несколько потоков -- таким образом
реализуется многопоточность приложений. ОС распределяет ресурсы CPU на уровне потоков. Каждый поток при этом характеризуется своим собственным контекстом исполнения (регистры,
стек).

__Планирование__ - определение следующего выполняющегося потока (а следовательно, процесса) на CPU.

Алгоритмы (дисциплины) планирования.

Планирование в пакетных (=неинтерактивных) системах
1) FIFO. Запускаемые процессы помещаются в очередь (FIFO). Следующим исполняемым процессом на CPU выбирается тот, кто располагается самым первым в очереди.
При использоваии данного алгоритма центральный процессор выделяется процессам в порядке поступления их запросов. При этом процесс исполняется на CPU до тех пор, пока не
будет заблокирован по причине выполнения операции ввода/вывода или пока не завершится.
2) Самое короткое задание первым. Следующим исполняемым на cpu заданием будет процесс, требующий самое короткое время для своего завершения. Эффективен, если задания доступны планировщику
одновременно. В случае последовательного поступления заданий превращается в алгоритм FIFO.
3) Приоритет наименьшему времени выполнения. Следующим исполняемым на cpu заданием будет процесс, оставшееся время исполнения которого минимально.

Планирование в интерактивных системах:
4) Циклическое планирование. Каждому процессу выделяется квант времени, в течение которого он может исполняться. По истечении этого кванта времени, процесс прерывается, и ресурсы CPU
переходят другому процессу. В случае если процесс перешел в заблокированное состояние по вводу/выводу или завершился, то планирование осуществляется именно в этот момент. По исчерпании кванта времени,
прерванный процесс помещается в конец FIFO. Следующим исполняемым процессом выбирается тот, кто находится в начале FIFO.
5) Приоритетное планирование. Аналогичен алгоритму циклического планирование, за исключением того, что каждому процессу присваивается приоритет. Следующим исполняемым на CPU процессом выбирается тот,
который находится в состоянии готовности (не заблокирован вводом/выводом) и имеет наивысший приоритет. В качестве реализации может быть использовано несколько очередей (FIFO).
Процессы разного приоритета помещаются в разные очереди.
6) Гарантированное планирование. Учитываются 3 характеристики:
t - время, в течение которого процесс исполнялся на CPU,
T - время, прошедшее с момента запуска процесса,
n - количество исполняющихся процессов.
ОС исходит из идеи, что каждый процесс имеет право на время CPU в размере t' = T/n (каждому процессу выделяется одинаковое количество процессорного времени).
Для каждого процесса подсчитываются величины d = t/t' = (t * n) / T. Следующим исполняемым процессом выбирается тот, у которого величина d наименьшая:
такой процесс "недополучил" больше процессорного времени, чем его конкуренты.
7) Лотерейное планирование. Следующий процесс выбирается при помощи датчика случайных чисел. Возможна настройка вероятности "быть выбранным", путём задания численных приоритетов и их учёта.

Взаимодействие процессов.

Одним из свойством процесса является его "изолированность" от других процессов: таким образом достигается иллюзия единоличного владения ресурсами компьютера.
Тем не менее, возникает необходимость обмена данными между различными процессами.
Существуют следующие механизмы межпроцессорного взаимодействия (на примере ОС Linux):

1) Использование разделяемых областей памяти. Нескольким процессам отображается в виртуальное адресное пространство одна и та же физическая страница оперативной памяти.
За счёт этого появляется возможность взаимодействия процессов через выделенную область памяти.
Использование разделяемой памяти доступно в ОС Linux через системный вызов mmap с флагом MAP_SHARED.
2) Сигналы. Сигналы UNIX (signals) являются ограниченным, но полезным способом межпроцессорной коммуникации. По сути, сигнал - это аналог прерывания для CPU.
При поступлении сигнала вызывается специальный обработчик процесса, который выполняет некоторые действия. Одни сигналы имеют чёткую семантику (как например, SIGALRM - сигнал от таймера),
семантика других же определяется самим процессом (как например, SIGUSR1, SIGUSR2).
3) UNIX-сокеты. Механизм работы данного способа межпроцессорного взаимодействия аналогичен обычным TCP/UDP сокетам. Один процесс (сервер) прослушивает определённый сокет,
идентифицируемый путём в VirtualFS (VFS). Другой процесс (клиент) "подключается" к этому сокету и посылает через него сообщения определённого формата.
Процесс-сервер получает данное сообщение и выполняет соответствующие действия. Подобный способ межпроцессорного взаимодействия использует большинство демонов (daemons) ОС.
4) Канал (pipe). Канал - механизм межпроцессорного взаимодействия между процессом-родителем и дочерним процессом. Процесс-родитель записывает данные в один из концов канала, идентифицируемый
файловым дескриптором на запись (fd). Дочерний процесс же считывает эти данные с другого конца (файловый дескриптор на чтение). Обычно создаваемые файловые дескрипторы заменяют stdin или stdout процесса,
поэтому межпроцессорное взаимодействие эффективно выглядит как получение пользовательского ввода/вывода.
5) Коммуникация через файлы. Обычные файлы VFS тоже могут являться способом взаимодействия процессов. При этом коммуницировать можно как через содержимое файла, так и через сам факт наличия файла.
Последнее используется в так называемых lock или pid файлах, которые свидетельствуют о наличии определённого процесса или о выполнении определённого действия в системе.
6) Сетевые сокеты TCP/UDP как способ взаимодействия удалённых процессов (исполняющихся на различных машинах).

Проблема тупиков.

При использовании разделяемых областей памяти (или вообще любых разделяемых ресурсов, к примеру, принтера) появляется необходимость синхронизации процессов:
иными словами, требуется некоторая сериализация выполняемых над разделяемых ресурсом операций так, чтобы исключить одновременное его использование.
Участок кода программы, работающий с разделяемым ресурсом (например, памятью), называется __критической секцией__.

Для безопасного использования разделяемого ресурса используются дополнительные переменные, семантика которых аналогична "светофору":
одно значение переменной, к примеру 0, говорит о том, что ресурс в настоящие момент не используется;
другое значение, к примеру любое ненулевое значение, говорит о том, что ресурс в настоящее время занят.

Необходимым условием возможности использования переменных для синхронизации является аппаратная поддержка атомарной операции __"test-and-set"__.
Данная операция выполняется по следующему алгоритму _атомарно_:
1) В переменную записывается ненулевое значение (например, 1).
2) Предыдущее значение переменной сохраняется в специальном регистре.
Программное обеспечение при этом имеет возможность узнать, успешно ли была взята блокировка, по значению, сохранённому в регистре.

Для сериализации исполняемых операций используются следующие примитивы синхронизации:
1) Cпинлок (spinlock) -- процесс пытается циклически выполнить операцию "test-and-set" до тех пор, пока не преуспеет.
2) Мьютекс (mutex) -- процесс прерывается операционной системой в случае неудачного выполнения операции "test-and-set".
В случае успеха процесс продолжает свою работу.
3) Семафор (semaphore) -- счётчик. Для его реализации часто задействуется атомарная операция compare-and-add,
помещающее в переменную не новое ненулевое значение, а сумму предыдущего и указанного в коде операции.
По сути подсчитывает оставшееся число разделяемого ресурса. В случае его отсутствия (счётчик = 0) процесс также прерывается.
Мьютекс иначе называется бинарным семафором.

__Проблема тупиков__ возникает при наличии нескольких процессов и нескольких разделяемых ресурсов.
Пример тупика:

                    Ресурсы
Процессы         1          2
                 ^          ^
                 |          |
   A     --------/          |
                            |
   B     -------------------/

Стрелочками нарисованы взятые разделяемые ресурсы 1, 2 каждым из процессов A и B.
После этого, если процесс A попытается взять ресурс 2, а процесс B - ресурс 1, возникнет ситуация тупика (__deadlock__).

Условия возникновения тупиков:
1) Условие взаимного исключения. Каждый ресурс либо выделен в данный момент только одному процессу, либо доступен.
2) Условие удержания и ожидания. Процессы, удерживающие в данный момент ранее выделенные им ресурсы, могут запрашивать новые ресурсы.
3) Условие невыгружаемости. Ранее выделенные ресурсы не могут быть принудительно отобраны у процесса. Они должны быть явным образом
высвобождены тем процессом, который их удерживает.
4) Условие циклического ожидания. Должна существовать кольцевая последовательность из двух и более процессов, каждый из которых ожидает высвобождения ресурса,
удерживаемого следующим членом последовательности.

Для возникновения тупика должны соблюдаться все четыре условия.

################################################################################

120. Методы и средства защиты информации в локальных вычислительных сетях от атак канального уровня
Для описания методов и средств защиты информации рассмотрим наиболее распространенные атаки канального уровня:
1)	ARP-spoofing (ARP-poisoning)
Address Resolution Protocol (ARP) – протокол канального уровня, использующийся для установления соответствия между IP-адресом и MAC-адресом машины. Для определения MAC-адреса получателя по IP-адресу хост формирует широковещательный Ethernet-кадр, содержащий ARP-запрос (ARP-Request). Запрос содержит MAC и IP отправителя и IP получателя. Хост, обнаруживший свой IP в поле "сетевой адрес получателя", дописывает свой MAC-адрес и отправляет ARP-ответ (ARP-Reply). Получив искомый MAC-адрес, хост заносит его в ARP-кэш, и в дальнейшем для отправки запросов пользуется полученным адресом.
Недостатком данного протокола является отсутствие проверки подлинности пакетов: как запросов, так и ответов. Злоумышленник, отправляя ARP-ответы без предварительного ARP-запроса, может подменить содержимое ARP-кэша произвольным образом и перехватывать трафик между узлами в пределах одного широковещательного домена.
Способы защиты от атаки ARP-spoofing:
−	использовать статическую ARP-таблицу. Необходимые соответствия адресов добавляются в ARP-таблицу и в дальнейшем не заменяются;
−	использовать VLAN. В случае, когда машины злоумышленника и жертвы будут расположены в разных виртуальных сетях, атака не будет возможна;
−	использовать Packet Filtering ACL на коммутаторах. Например, современные коммутаторы DLINK и CISCO поддерживают инструменты анализа пакетов и фильтрацию по конкретным параметрам. Первый вариант: фильтрация всех ARP-пакетов на всех пользовательских портах, у которых в Sender Protocol Address содержится IP-адрес шлюза, что позволяет защититься от подмены адреса шлюза. Второй вариант: фильтрация всех ARP-пакетов на каждом из пользовательских портов, у которых Sender Hardware Address и Sender Protocol Address отличаются уже известных MAC и IP-адресов, что позволяет защититься еще и от подмены адреса некоторого пользователя.
2)	Атаки MAC-spoofing, MAC-flooding
MAC-spoofing – атака канального уровня, суть которой заключается в изменении MAC-адреса сетевого устройства. Благодаря этому коммутатор начинает отправлять на порт, к которому подключен злоумышленник, пакеты, которые он до этого видеть не мог.
MAC-flooding (переполнение таблицы коммутации) – атака, основанная на том, что таблица коммутации в коммутаторах имеет ограниченный размер. После заполнения таблицы, коммутатор не может более запоминать новые MAC-адреса и начинает отправлять трафик на все порты.
Для защиты от этих атак можно использовать функцию коммутатора Port Security: она позволяет указать список MAC-адресов, которым разрешено передавать данные через порт, и дополнительно позволяет ограничить количество подключений на интерфейсе.
3)	Атаки на DHCP-сервер
К основным атакам этого класса относятся:
−	DoS DHCP-сервера. Злоумышленник может сформировать и послать DHCP-серверу огромное количество DHCP-запросов с разными MAC-адресами. Сервер будет выделять IP-адреса из пула, который через некоторое время закончится, после чего DHCP-сервер не сможет обслуживать новых клиентов. Для защиты от этой атаки используется метод DHCP Snooping, который заключается в сравнении MAC-адреса, указанного в DHCP-запросе, с MAC-адресом, который прописан на порту коммутатора. Если адреса не совпадают – пакет отбрасывается, иначе принимается;
−	«Ложный» DHCP-сервер. Злоумышленник может развернуть свой DHCP-сервер и выдавать свои настройки пользователям сети, обеспечивая себе возможность прослушивания трафика, подделки DNS-ответов и т.д.. Для этого необходимо предварительно вывести из строя легальный DHCP-сервер (например, с помощью DoS), следовательно, защита от атаки будет происходить аналогичным образом.
4)	Атака VLAN hopping
VLAN – виртуальная сеть, хосты в которой взаимодействуют друг с другом так, как если бы они были подключены к одному широковещательному домену, независимо от их физического местоположения. Порты коммутаторов, принадлежащие одной VLAN, могут обмениваться кадрами между собой, но не могут обмениваться кадрами с портами других VLAN. При этом порты, предназначенные для передачи кадров только одной виртуальной сети, называются портами доступа, а порты, предназначенные для передачи кадров нескольких VLAN – магистральными, или «транковыми».
VLAN hopping – общее название для атак, которые предполагают проникновение в VLAN, который до выполнения атаки не был доступен атакующему.
Основной атакой этого класса является атака с использованием Dynamic Trunking Protocol (DTP), когда злоумышленник через свой порт отправляет пакет DTP, в результате чего коммутатор считает этот порт магистральным.
Для создания ЛВС, защищенных от атак этого класса, используются следующие принципы:
−	запретить передачу кадров собственной VLAN по магистральным каналам, а в качестве native VLAN использовать VLAN, специально выделенную для этих целей;
−	не использовать стандартную VLAN 1, особенно для управления сетевым оборудованием;
−	на магистральных портах использовать только необходимые VLAN – VLAN, все прочие запрещать;
−	не использовать одинаковые VLAN на разных коммутаторах;
−	все неиспользуемые порты коммутатора переводить в режим shutdown и определять их в отдельную изолированную VLAN.
5)	Атаки на STP
Протокол Spanning Tree Protocol (STP) предназначен для предотвращения зацикливания пакетов  сети при наличии дублирующих маршрутов. Для этого сначала производится обнаружение коммутаторов, которые связаны между собой. Далее среди них выбирается главный, корневой коммутатор (root bridge), после чего блокируются порты коммутатора, которые создают петли в получившейся топологии.
Для построения древовидной структуры без петель в сети должен быть определен корневой коммутатор, от которого и будет строиться это дерево. В качестве корневого коммутатора выбирается коммутатор с наименьшим значением идентификатора. Идентификатор – это число длиной 8 байт, 6 младших байтов которого составляет MAC-адрес его блока управления, а 2 старших байта конфигурируются вручную, что позволяет администратору сети влиять на процесс выбора корневого коммутатора. Если администратор не вмешается в данный процесс, в качестве корневого будет выбран коммутатор с наименьшим MAC-адресом блока управления. Такой выбор может быть далеко не рациональным, поэтому рекомендуется выбирать корневой коммутатор исходя из топологии сети и назначать ему наименьший идентификатор вручную. Далее для каждого коммутатора определяется корневой порт (root port) – порт, который имеет кратчайшее расстояние до корневого коммутатора. Для каждого логического сегмента сети выбирается назначенный мост (designated bridge), один из портов которого будет принимать пакеты от сегмента и передавать их в направлении корневого коммутатора через корневой порт данного моста.
В процессе атаки злоумышленник может притвориться коммутатором так же, как и в атаке VLAN hopping, и направить в сторону атакуемого коммутатора BDPU-пакет с подделанным приоритетом и MAC-адресом, чтобы в результате самому стать корневым коммутатором и с его помощью перехватывать сетевой трафик.
Для защиты от атак этого класса используются следующие принципы:
−	использовать протоколы семейства STP с целью построения отказоустойчивых ЛВС только при необходимости. По возможности использовать механизмы и протоколы маршрутизации сетевого уровня;
−	административно определять и назначать корневые коммутаторы. Использовать дополнительные механизмы и средства защиты протокола STP (RootGuard, LoopGuard, UplinkFast, UDLD) для предотвращения получения роли корневого коммутатора другими коммутаторами;
−	на портах доступа коммутаторов ЛВС выполнять настройки по предотвращению возможности появления или фильтрации BPDU-пакетов протокола STP (механизмы BPDU Guard и BPDU Filter соответственно), а также выполнять настройки для быстрого включения и защиты корневого коммутатора (механизмы PortFast и RootGuard соответственно).

################################################################################

96. Вредоносные программы: классификация, основные характеристики, современные тенденции в развитии вредоносных программ
Вредоносная программа – программа, используемая для осуществления несанкционированного доступа к информации и (или) воздействия на информацию или ресурсы автоматизированной информационной системы (из ГОСТ 51275-2006 Защита информации. Объект информатизации…).
Классификация вредоносных программ:
1)	Вирус – самовоспроизводящийся программный код, который внедряется в установленные программы без согласия пользователя. В дополнение к этому вирус может быть запрограммирован на выполнение вредоносных действий (например, удаление или порча файлов) и самомодификацию. Примеры: Virus 1, 2, 3, Elk Cloner, «Чернобыль».
2)	Червь – саморазмножающаяся программа, которая поселяется на компьютер жертвы, а затем ищет уязвимости в Сети или системе для дальнейшего распространения себя. Некоторые черви существуют в виде сохраненных на жестком диске файлов, а некоторые поселяются в оперативной памяти компьютера. Примеры: червь Морриса, Stuxnet, Wanna Cry.
3)	Троян – вредоносная программа, которая отличается от самопроизвольно распространяющихся вирусов и червей тем, что она распространяется злоумышленниками. Большинство троянских программ маскируется под безвредные или полезные программы, чтобы пользователь загрузил/установил их на свой компьютер. Злоумышленники помещают троянские программы на открытые и индексируемые ресурсы, носители информации, присылают их предполагаемым жертвам по электронной почте, также трояны устанавливаются на компьютер через бреши безопасности. Примеры: Trojan.Spy, Trojan.Downloader, Trojan.SMS.
4)	Руткит – вредоносная программа, специально разработанная для сокрытия присутствия вредоносного кода  и его действий от пользователя и установленного защитного программного обеспечения. Некоторые руткиты могут начинать свою работу прежде, чем загрузится операционная система (буткит). Примеры: Blue Pill, Haxdoor, Mebroot. 
5)	Бэкдор (средство удаленного администрирования) – приложение, которое позволяет злоумышленнику управлять компьютером на расстоянии. В зависимости от функциональных особенностей конкретного бэкдора, злоумышленник может установить и запустить на компьютере любое программное обеспечение, сохранять все нажатия клавиш, загружать и сохранять файлы, делать снимки с веб-камеры и т.п. Примеры: Linux.Backdoor.*, Python.Backdoor.*, Backdoor:MSIL/Sorcas.A.
6)	Загрузчик – небольшая программа, которая используется лишь для дальнейшей загрузки и установки полной версии вредоносной программы. После того, как загрузчик попадает на компьютер жертвы (например, после открытия вложения из полученного письма), он соединяется с удаленным сервером и загружает всю вредоносную программу. Пример: Nemucode.
7)	Вредоносные утилиты – программы, разработанные для автоматизации создания других вредоносных программ, организации DoS-атак на удаленные сервера, взлома компьютеров и т.д. В отличие от предыдущих категорий, такие программы не представляют угрозы компьютеру, на котором исполняются. Примеры: Email-Flooder, DoS, Spoofer.
8)	Нежелательное ПО – программы, которые по своей сути не являются вредоносными, но в большинстве случаев могут надоедать пользователю. Примеры: AdWare, SpyWare, zip-bomb.

Основные характеристики вредоносных программ:
−	целевая среда. Устройства, операционные системы, приложения и т.п.;
−	механизм передачи. Съемные носители, общие сетевые диски, сеть, электронная почта и т.п.;
−	вредоносные действия. Порча, уничтожение, хищение информации, отказ в обслуживании и т.п.;
−	механизмы активации. Ручной (социальная инженерия), полуавтоматический, автоматический (в том числе по событию);
−	механизмы защиты. Обфускация, упаковка, генерация мусора, олигоморфизм, полиморфизм, метаморфизм, обратные атаки на антивирусное программное обеспечение.

Современные тенденции в развитии вредоносных программ:
−	использование техники «living off the land». Злоумышленники, чтобы избежать обнаружения, всё чаще используют программы, которые уже установлены у жертв. Так, например, NotPetya распространялся по сети благодаря утилите PSExec и инструментария управления Windows (WMI). Эти инструменты не классифицируются как угрозы, потому что являются легитимным программным обеспечением, и поэтому не детектируются сканерами;
−	использование «plug-and-play» червей. Злоумышленники после инцидента с WannaCry стали намного чаще полагаться на возможности распространения червей по сети и их последующее закрепление в системе путем планирования задач и формирования бэкдоров;
−	использование аппаратных уязвимостей для проведения атак. После обнаружения уязвимостей Meltdown и Spectre, позволяющих вредоносным приложениям получать доступ к конфиденциальным данным из памяти, злоумышленники выделили их в качестве приоритетных. По материалам ЛК, отдельные APT группировки уже тестируют образцы вредоносных программ, использующих эти уязвимости. 
Дополнительно можно рассказать про внимание к IoT устройствам и увеличению количества вредоносных программ для мобильных устройств.

################################################################################

97. Компьютерные вирусы: классификация, основные характеристики, способы внедрения в программный код, способы сокрытия факта заражения и основные демаскирующие признаки
Компьютерный вирус – самовоспроизводящийся программный код, который внедряется в установленные программы без согласия пользователя. В дополнение к этому вирус может быть запрограммирован на выполнение вредоносных действий (например, удаление или порча файлов) и самомодификацию.

Классификация вирусов:
1)	По целевой среде
-	компьютерные вирусы для различных аппаратных платформ (вирусы для определенной аппаратной платформы, межплатформные вирусы, платформно-независимые вирусы (вирусы виртуальных машин – Java-вирусы, .NET-вирусы));
-	компьютерные вирусы для различных операционных систем (вирусы для определенных ОС, переносимые вирусы (за счет бинарной совместимости ОС, за счет переносимости исходного кода, например, скрипт-вирусы)).
2)	По объекту-носителю
-	вирусы для исполняемых файлов (COM-вирусы, EXE-вирусы (различают MZ-, PE-вирусы), COFF/ELF-вирусы);
-	вирусы для исполняемых объектов (COM/ActiveX-вирусы, Java-вирусы, .NET-вирусы);
-	загрузочные вирусы;
-	скрипт-вирусы;
-	макровирусы;
-	комбинированные.

Выбор объекта-носителя может происходить следующим образом:
-	произвольная жертва (заражется всё подряд);
-	по определенным критериям (заражение происходит, например, только определенных ОС);
-	только конкретные объекты (например, только PE-файлы).
3)	По способу заражения
-	классические вирусы (внедряются в объект-носитель, стараясь максимально скрыть своё присутствие);
-	"вандалы" (внедряются в объект-носитель, не стараясь скрыть своё присутствие, могут повредить объект-носитель);
-	"спутники" (существуют в виде отдельного объекта "рядом" с носителем, заражения как такового не происходит).
4)	По принципу выбора жертвы
-	вирусы-сканеры (определяют жертву в момент своей активации);
-	вирусы-мониторы (отслеживают активность потенциальных объектов-носителей с целью определения возможности заражения).
5)	По размещению в системе
-	резидентный вирус при заражении компьютера оставляет в оперативной памяти свою резидентную часть, которая потом перехватывает обращение операционной системы к объектам заражения (файлам, загрузочным секторам дисков и т.п.) и внедряется в них. Резидентные вирусы находятся в памяти и являются активными вплоть до выключения или перезагрузки компьютера;
-	нерезидентный вирус не заражает память компьютера и является активным ограниченное время. Активизируется в определенные моменты, например, при обработке документов текстовым редактором.
6)	По способу активации
-	ручная (социальная инженерия);
-	автоматическая (характерная для загрузочных вирусов, а также для файловых вирусов с возможностью автозапуска программы);
-	полуавтоматическая (характерная для "спутников");
-	логические бомбы (по наступлению определенного события);
-	временные бомбы (по наступлению определенного момента времени).
7)	По способу защиты от удаления
-	незащищенные вирусы;
-	зашифрованные вирусы (в том числе упаковка);
-	размазывание вируса (записывается в свободные участки объекта-носителя с использованием переходов);
-	обфускация;
-	олигоморфизм (низкий уровень защиты от сигнатурного поиска);
-	полиморфизм (средний уровень защиты от сигнатурного поиска);
-	метаморфизм (высокий уровень защиты от сигнатурного поиска);
-	активная защита (нападение на антивирусные средства, дополнительные средства от анализа).

Способы внедрения в программный код:
-	размещение X-кода поверх оригинальной программы (затирание);
-	размещение X-кода в свободном месте программы (интеграция);
-	дописывание X-кода в начало, середину или конец файла с сохранением оригинального содержимого;
-	размещение X-кода вне основного тела файла-носителя (например, в динамической библиотеке или NTFS-потоке), загружаемого "головой" X-кода, внедренной в файл способами 1-3.

Способы сокрытия факта заражения:
-	стелс-вирусы. При попытке чтения зараженного сектора диска эти вирусы "подставляют" вместо себя незараженный оригинал;
-	обфускация. Код вируса обрабатывается таким образом, что его становится сложно анализировать исследователю, но функциональность при этом сохраняется;
-	упаковка. Тело вируса сжимается и исполняется только после распаковки декриптором, который прикрепляется к упакованному телу вируса (примеры: UPX, ASpack);
-	генерация мусора. Код вируса "разбавляется" бесполезными инструкциями, которые затрудняют его анализ и мешают сигнатурному анализу;
-	пермутация. Перестановка логических блоков в теле вируса;
-	полиморфизм. Для упаковки вируса каждый раз используется новый ключ, зависимый, например, от объема файла, который он инфицирует;
-	метаморфизм. То же, что и полиморфизм, но в каждом поколении вирусов генерируется новый код декриптора, что мешает сигнатурному анализу;
-	"антипесочница". Вирус не проявляет (либо проявляет позднее) свои деструктивные свойства, если определяет окружающую среду как виртуальную.

Основные демаскирующие признаки:
-	наличие нетипичного стартового поведения в момент загрузки программы;
-	наличие известных сигнатур (в том числе строковые, который явно выдают присутствие вируса);
-	нетипичный набор секций, измененные имена секций;
-	нетипичные таблицы импорта.


