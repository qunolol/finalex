46.	Принятие решений при разработке программ. Формальное обоснование принятых решений. Вариантный сектор, вариантная сеть


################################################################################

49. Операционные системы: подходы к определению операционной системы как вида программного обеспечения,
функции операционных систем, архитектурные типы, современные тенденции в развитии операционных систем.
==============================================================================================================

__Операционная система__ - вид программного обеспечения, управляющего работой вычислительной системы, а также
расширяющего возможности ЭВМ.

ПОДХОДЫ
1) ОС как расширенная машина.

ОС предоставляет сервисы приложениям пользовательского уровня:
    - Системные вызовы.
    Системные вызовы - это, по сути, механизм, с помощью которого пользовательские приложения запрашивают
    выполнение некоторого действия от ОС. Типичными примерами системных вызовов являются порождение дочернего процесса,
    открытие/закрытие нового файла, запись/чтение в/из файл(а).
    - Абстракции (файлы, сокеты) для доступа к устройствам ввода/вывода.
    Ключевой особенностью является единообразие интерфейса независимо от конкретного оборудования
    (сетевая карта, жёсткий диск). В данном случая ядро (kernel) операционной системы преобразует
    системные вызовы в обращения к конкретным драйверам периферийного оборудования. За счёт этого
    упрощается разработка программного обеспечения.
    - Виртуализация. Концепция "процесса" как программы, исполняющейся на виртуальном процессоре, позволяет предоставить программе
    видение, будто она единолично исполняется на процессоре и в её распоряжении находится всё оперативная память.
    Здесь важно отметить, что без аппаратной поддержки (MMU, прерывания) данные возможности не были бы доступны.
Таким образом, ОС расширяет возможности компьютера, является как бы "новым уровнем" в архитектуре компьютера.

2) ОС как менеджер ресурсов.

В данном подходе считается, что основная задача ОС - упорядоченное и управляемое распределение ресурсов:
    процессора;
    оперативной памяти;
    устройств ввода-вывода
-- между различными программами, претендующими на их использование.

Функции операционных систем:

1) Распределение ресурсов программам -- "процессам": процессорное время, память, устройства ввода/вывода.
2) Управление устройствами компьютера: обслуживание прерываний, конфигурирование оборудование (plug & play).
3) Предоставление сервиса пользовательским приложениям -- выполнение системных вызовов.
4) Виртуализация -- поддержка виртуализации (примеры: VirtualBox, Qemu/KVM)
5) Безопасность -- управление доступом, системы разграничения доступа пользователей, уровни привилегий.
6) Упрощение разработки программного обеспечения -- предоставление библиотек (shared objects), упрощение загрузки программ, облегчение переносимости кода.

Архитектурные типы ("Зоопарк"):

* ОС мейнфреймов
* ОС серверов
* ОС персональных компьютеров
* ОС встраиваемых систем
* ОС реального времени

Тенденции:

* Поддержка большего числа архитектур CPU.
* Поддержка большего количества периферийных устройств.
* Оптимизация кода: внедрение большого числа микро- и архитектурно-зависимых оптимизаций.
* Сохранение обратной совместимости с пользовательским ПО (сохранение бинарного интерфейса системных вызовов).
* Hardening (усиление безопасности, фикс уязвимостей, внедрение новых мер безопасности).
* Сетевые возможности: поддержка многих сетевых карт, реализация известных сетевых протоколов канального, сетевого, транспортного уровней, добавление
  новых возможностей по конфигурированию сети (пример, nl80211 -- конфигурирование Wi-Fi, netlink -- замена интерфейса ioctl'ов для сетевых модулей).
* Поддержка аппаратной виртуализации (KVM -- поддержка Intel VT-x).

################################################################################

50. Управление процессами и потоками: представление процессов и потоков в операционных системах, дисциплины планирования процессов, взаимодействие процессов, проблема тупиков.

__Процесс__ - абстракция, описывающая исполняемую на компьютере программу. Процесс является единицей управления ресурсами: иными словами, ОС планирует ресурсы ЭВМ на уровне процессов
(за исключением, CPU). Каждый процесс характеризуется своей собственной виртуальной памятью, а также своими ресурсами ввода/вывода (открытые файлы, используемые сокеты).
__Поток__ - исполняемая единица. Любой поток принадлежит некоторому процессу, исполняется в его контексте. При этом каждый процесс может иметь несколько потоков -- таким образом
реализуется многопоточность приложений. ОС распределяет ресурсы CPU на уровне потоков. Каждый поток при этом характеризуется своим собственным контекстом исполнения (регистры,
стек).

__Планирование__ - определение следующего выполняющегося потока (а следовательно, процесса) на CPU.

Алгоритмы (дисциплины) планирования.

Планирование в пакетных (=неинтерактивных) системах
1) FIFO. Запускаемые процессы помещаются в очередь (FIFO). Следующим исполняемым процессом на CPU выбирается тот, кто располагается самым первым в очереди.
При использоваии данного алгоритма центральный процессор выделяется процессам в порядке поступления их запросов. При этом процесс исполняется на CPU до тех пор, пока не
будет заблокирован по причине выполнения операции ввода/вывода или пока не завершится.
2) Самое короткое задание первым. Следующим исполняемым на cpu заданием будет процесс, требующий самое короткое время для своего завершения. Эффективен, если задания доступны планировщику
одновременно. В случае последовательного поступления заданий превращается в алгоритм FIFO.
3) Приоритет наименьшему времени выполнения. Следующим исполняемым на cpu заданием будет процесс, оставшееся время исполнения которого минимально.

Планирование в интерактивных системах:
4) Циклическое планирование. Каждому процессу выделяется квант времени, в течение которого он может исполняться. По истечении этого кванта времени, процесс прерывается, и ресурсы CPU
переходят другому процессу. В случае если процесс перешел в заблокированное состояние по вводу/выводу или завершился, то планирование осуществляется именно в этот момент. По исчерпании кванта времени,
прерванный процесс помещается в конец FIFO. Следующим исполняемым процессом выбирается тот, кто находится в начале FIFO.
5) Приоритетное планирование. Аналогичен алгоритму циклического планирование, за исключением того, что каждому процессу присваивается приоритет. Следующим исполняемым на CPU процессом выбирается тот,
который находится в состоянии готовности (не заблокирован вводом/выводом) и имеет наивысший приоритет. В качестве реализации может быть использовано несколько очередей (FIFO).
Процессы разного приоритета помещаются в разные очереди.
6) Гарантированное планирование. Учитываются 3 характеристики:
t - время, в течение которого процесс исполнялся на CPU,
T - время, прошедшее с момента запуска процесса,
n - количество исполняющихся процессов.
ОС исходит из идеи, что каждый процесс имеет право на время CPU в размере t' = T/n (каждому процессу выделяется одинаковое количество процессорного времени).
Для каждого процесса подсчитываются величины d = t/t' = (t * n) / T. Следующим исполняемым процессом выбирается тот, у которого величина d наименьшая:
такой процесс "недополучил" больше процессорного времени, чем его конкуренты.
7) Лотерейное планирование. Следующий процесс выбирается при помощи датчика случайных чисел. Возможна настройка вероятности "быть выбранным", путём задания численных приоритетов и их учёта.

Взаимодействие процессов.

Одним из свойством процесса является его "изолированность" от других процессов: таким образом достигается иллюзия единоличного владения ресурсами компьютера.
Тем не менее, возникает необходимость обмена данными между различными процессами.
Существуют следующие механизмы межпроцессорного взаимодействия (на примере ОС Linux):

1) Использование разделяемых областей памяти. Нескольким процессам отображается в виртуальное адресное пространство одна и та же физическая страница оперативной памяти.
За счёт этого появляется возможность взаимодействия процессов через выделенную область памяти.
Использование разделяемой памяти доступно в ОС Linux через системный вызов mmap с флагом MAP_SHARED.
2) Сигналы. Сигналы UNIX (signals) являются ограниченным, но полезным способом межпроцессорной коммуникации. По сути, сигнал - это аналог прерывания для CPU.
При поступлении сигнала вызывается специальный обработчик процесса, который выполняет некоторые действия. Одни сигналы имеют чёткую семантику (как например, SIGALRM - сигнал от таймера),
семантика других же определяется самим процессом (как например, SIGUSR1, SIGUSR2).
3) UNIX-сокеты. Механизм работы данного способа межпроцессорного взаимодействия аналогичен обычным TCP/UDP сокетам. Один процесс (сервер) прослушивает определённый сокет,
идентифицируемый путём в VirtualFS (VFS). Другой процесс (клиент) "подключается" к этому сокету и посылает через него сообщения определённого формата.
Процесс-сервер получает данное сообщение и выполняет соответствующие действия. Подобный способ межпроцессорного взаимодействия использует большинство демонов (daemons) ОС.
4) Канал (pipe). Канал - механизм межпроцессорного взаимодействия между процессом-родителем и дочерним процессом. Процесс-родитель записывает данные в один из концов канала, идентифицируемый
файловым дескриптором на запись (fd). Дочерний процесс же считывает эти данные с другого конца (файловый дескриптор на чтение). Обычно создаваемые файловые дескрипторы заменяют stdin или stdout процесса,
поэтому межпроцессорное взаимодействие эффективно выглядит как получение пользовательского ввода/вывода.
5) Коммуникация через файлы. Обычные файлы VFS тоже могут являться способом взаимодействия процессов. При этом коммуницировать можно как через содержимое файла, так и через сам факт наличия файла.
Последнее используется в так называемых lock или pid файлах, которые свидетельствуют о наличии определённого процесса или о выполнении определённого действия в системе.
6) Сетевые сокеты TCP/UDP как способ взаимодействия удалённых процессов (исполняющихся на различных машинах).

Проблема тупиков.

При использовании разделяемых областей памяти (или вообще любых разделяемых ресурсов, к примеру, принтера) появляется необходимость синхронизации процессов:
иными словами, требуется некоторая сериализация выполняемых над разделяемых ресурсом операций так, чтобы исключить одновременное его использование.
Участок кода программы, работающий с разделяемым ресурсом (например, памятью), называется __критической секцией__.

Для безопасного использования разделяемого ресурса используются дополнительные переменные, семантика которых аналогична "светофору":
одно значение переменной, к примеру 0, говорит о том, что ресурс в настоящие момент не используется;
другое значение, к примеру любое ненулевое значение, говорит о том, что ресурс в настоящее время занят.

Необходимым условием возможности использования переменных для синхронизации является аппаратная поддержка атомарной операции __"test-and-set"__.
Данная операция выполняется по следующему алгоритму _атомарно_:
1) В переменную записывается ненулевое значение (например, 1).
2) Предыдущее значение переменной сохраняется в специальном регистре.
Программное обеспечение при этом имеет возможность узнать, успешно ли была взята блокировка, по значению, сохранённому в регистре.

Для сериализации исполняемых операций используются следующие примитивы синхронизации:
1) Cпинлок (spinlock) -- процесс пытается циклически выполнить операцию "test-and-set" до тех пор, пока не преуспеет.
2) Мьютекс (mutex) -- процесс прерывается операционной системой в случае неудачного выполнения операции "test-and-set".
В случае успеха процесс продолжает свою работу.
3) Семафор (semaphore) -- счётчик. Для его реализации часто задействуется атомарная операция compare-and-add,
помещающее в переменную не новое ненулевое значение, а сумму предыдущего и указанного в коде операции.
По сути подсчитывает оставшееся число разделяемого ресурса. В случае его отсутствия (счётчик = 0) процесс также прерывается.
Мьютекс иначе называется бинарным семафором.

__Проблема тупиков__ возникает при наличии нескольких процессов и нескольких разделяемых ресурсов.
Пример тупика:

                    Ресурсы
Процессы         1          2
                 ^          ^
                 |          |
   A     --------/          |
                            |
   B     -------------------/

Стрелочками нарисованы взятые разделяемые ресурсы 1, 2 каждым из процессов A и B.
После этого, если процесс A попытается взять ресурс 2, а процесс B - ресурс 1, возникнет ситуация тупика (__deadlock__).

Условия возникновения тупиков:
1) Условие взаимного исключения. Каждый ресурс либо выделен в данный момент только одному процессу, либо доступен.
2) Условие удержания и ожидания. Процессы, удерживающие в данный момент ранее выделенные им ресурсы, могут запрашивать новые ресурсы.
3) Условие невыгружаемости. Ранее выделенные ресурсы не могут быть принудительно отобраны у процесса. Они должны быть явным образом
высвобождены тем процессом, который их удерживает.
4) Условие циклического ожидания. Должна существовать кольцевая последовательность из двух и более процессов, каждый из которых ожидает высвобождения ресурса,
удерживаемого следующим членом последовательности.

Для возникновения тупика должны соблюдаться все четыре условия.

################################################################################

51. Управление оперативной памятью: управление физической и виртуальной памятью, реализация свопинга.

Современные CPU имеют одним из компонент диспетчер памяти (MMU, Memory Management Unit).
Задача MMU -- преобразовывать поступающие на входе виртуальные адреса в физические,
реально выставляемые на адресных линиях системной шины.
Данный аппаратный компонент является основой построения виртуальной памяти.
Программное управление диспетчером памяти осуществляется через специальные регистры CPU,
а также через структуры данных, находящиеся в оперативной памяти (такие структуры данных описывают правила
преобразования виртуального адреса в физический).

Виртуальная память:

Виртуальное адресное пространство состоит из блоков фиксированного размера (обычно 4 Кб), называемых страницами.
Соответствующие блоки в физической памяти называются страничными блоками. Страницы и страничные блоки имеют,
как правило, одинаковые размеры. Перенос информации между оперативной памятью и диском (при свопинге) всегда осуществляется целыми страницами.

Пример организации виртуальной памяти (надо просто понять суть по диаграмме, учить дословно необязательно :)):

             ВИРТУАЛЬНАЯ ПАМЯТЬ
                     --------
               60-64K|  x   |
                     --------
               56-60K|  x   |
                     --------
               52-56K|  x   |
                     --------
               49-52K|  x   |
                     --------
               44-48K|  7   |-----------\
                     --------            \
               40-44K|  x   |             \
                     --------              \
               36-40K|  5   |----\          \
                     --------     \          \
               32-36K|  x   |      \          \     ФИЗИЧЕСКАЯ ПАМЯТЬ    PFN (Page Frame Number)
                     --------       \          \        --------
               28-32K|  x   |        \          \------>|      |28-32K             7
                     --------         \                 --------
               24-28K|  x   |          \  /------------>|      |24-28K             6
                     --------           \/              --------
               20-24K|  3   |------\    /\------------->|      |20-24K             5
                     --------       \  /                --------
               16-20K|  4   |--------\/---------------->|      |16-20K             4
                     --------        /\                 --------
               12-16K|  0   |------\/  \--------------->|      |12-16K             3
                     --------      /\                   --------
                8-12K|  6   |-----/  \    /------------>|      |8-12K              2
                     --------         \  /              --------
                 4-8K|  1   |----------\/-------------->|      |4-8K               1
                     --------          /\               --------
                 0-4K|  2   |---------/  \------------->|      |0-4K               0
                     --------                           --------

На диаграмме выше приняты следующие обозначения: диапазон, помеченный 0-4K означает, что виртуальные
или физические адреса этой страницы составляют от 0 до 4095. Диапазон 4-8K ссылается на адреса от
4096 до 8191 включительно и так далее. Каждая страница содержит строго 4096 адресов, которые начинаются с чисел,
кратных 4096, и заканчиваются числама на единицу меньше чисел, кратных 4096.
К примеру, когда программа обращается к памяти по адресу 0, диспетчеру памяти поступает на вход виртуальный адрес 0.
Диспетчер памяти вычисляет, что адрес относится к нулевой виртуальной странице. Данной странице соответствует физический блок с PFN=2.
Соответственно, на адресные линии выставляет значение 8192. Оперативная память не знает о существовании диспетчера и видит только запрос на чтение/запись
по адресу 8192, который и выполняет. Таким образом, диспетчер памяти эффективно справляется с отображением всех виртуальных адресов в диапазоне [0, 4095] на
физические адреса [8192, 12 287]. По аналогии происходят трансляции и в других виртуальных страницах.

Важно отметить, что во всех случаях отображение имеет характер один-к-одному (биекция).

Сама по себе возможность отображения 16 виртуальных страниц на 8 страничных блоков за счёт соответствующей настройки таблиц диспетчера
не решает проблемы превышения объема виртуальной памяти над объемом физической памяти. Поскольку в нашем распоряжении только 8 физических страничных блоков, то на
физическую память могут отображаться только 8 виртуальных страниц. Остальные страницы, помеченные на рисунке крестиками, в число отображаемых не попадают.
Реальное оборудование отслеживает присутствие конкретных страниц в физической памяти за счёт __бита присутствия-отсутствия__.

В случае если программа обращается к странице, на данный момент не отображенной в оперативную память, диспетчер памяти генерирует исключение "отсутствие страницы"
(page fault). Операционная система выбирает редко используемый страничный блок и сбрасывает его содержимое на диск. Затем она извлекает с диска запрошенную страницу,
помещает её в только что освободившийся страничный блок, вносит изменения в таблицы трансляций и заново запускает прерванную инструкцию.

Алгоритмы замещения страниц.

В случае возникновения `page fault`-исключения, ядро операционной системы должно выбрать страницу, которую требуется поместить на диск.
Есть различные подходы к тому, какую именно страницу необходимо выбрать:

1) NRU (Not Recently Used, исключение давно не использовавшейся страницы). Данный алгоритм реализуется на основе двух битов дескрипторов страниц, управляемых как аппаратно, так и программно:
   * R - устанавливается при каждом обращении к странице;
   * M - устанавливается при изменении страницы.
При запуске процесса оба страничных бита по умолчанию равны 0.
Периодически (например, по прерыванию от таймера) бит R сбрасывается, чтобы отличить те страницы,
к которым в последнее время были обращения от тех, к которым обращений не было.
При возникновении ошибки отсутствия страницы ядро операционной системы просматривает все страницы и на основе текущих значений
битов M, R делит их на четыре класса:
   * Класс 0: в последнее время не было ни обращений, ни модификаций.
   * Класс 1: обращений в последне время не было, но страница модифицирована.
   * Класс 2: в последнее время были обращения, но модификаций не было.
   * Класс 3: были и обращения, и модификации в последнее время.
Страницы класса 1 появляются в том случае, если у страниц класса 3 бит R сбрасывается по прерыванию от таймера.
Эти прерывания не сбрасывают бит M, поскольку содержащаяся в нём информация необходима для того, чтобы узнать,
нужно ли перезаписывать страницу на диске. Сброс бита R без бита M приводит к возникновению страниц класса 1.
Алгоритм NRU удаляет произвольную страницу, относящуюся к самому низкому непустому классу.
В основе алгоритма заложена идея, что лучше удалить модифицированную страницу, к которой не было обращений по крайней мере
за последний такт системных часов, чем удалить интенсивно используемую страницу.
Алгоритм NRU позволяет достичь приемлемой производительности.
2) FIFO. Операционная система ведёт список всех физических страниц. Недавно загруженные с диска страницы поступают в конец списка.
При возникновении исключения отсутствия страницы удаляется страница, находящаяся в голове списка.
3) Алгоритм "Второй Шанс". Модификация алгоритма FIFO, учитывающая бит R. У страницы, находящейся в голове списка, проверяется бит R.
Если он равен 1, то бит сбрасывается, а сама страница помещается в конец списка, но не удаляется. Если он равен 0, то действия аналогичны алгоритму FIFO.
Если страница не удалена, то проверяется следующая по очередности страница. С ней происходят те же самые проверки и операции.
Вырожденный случай -- все страницы были использованы. В таком случае по алгоритму у каждой страницы будет сброшен бит R, а суммарный эффект будет аналогичен алгоритму FIFO.
Эффективная реализация данного алгоритма -- манипулирования одними указателями без физического перемещения дескрипторов страниц.
4) LRU (Least Recently Used, исключение наименее востребованной страницы). Для каждой страницы ведётся специальнй счётчик.
При возникновении прерывания от таймера операционная система сканирует все страницы и добавляет к счётчику каждой страницы текущее значение R.
После этого значение R также сбрасывается. При возникновении ошибки отсутствия страницы, удаляется страница, имеющая наиманьшее значение счётчика.
5) "Рабочий набор".
Данный метод основывается на том наблюдении, что большинство программ обращается к адресному пространству неравномерно.
Набор страниц, используемых процессом в настоящий момент, называется __рабочим_набором__.
На практике приближённо определить рабочий набор можно по критерию: рабочий набор - страницы, к которым были обращения за последние N мс
(время виртуальное, равное интервалу времени, в течение которого задача исполняется на CPU).
При возникновении ошибки отсутствия страницы выбирается страница, не принадлежащая рабочему набору.

################################################################################

52. Управление устройствами ввода/вывода: система прерываний, системы драйверов внешних устройств.

CPU взаимодействует с периферийным оборудованием, выставляя на адресных линиях системной шины специальные адреса, воспринимаемые контроллером внешнего устройства.
Данный метод взаимодействия называется отображенным в память вводом/выводом (MMIO, Memory Mapped Input/Output).
Таким образом, используя привычные инструкции пересылки из памяти/в памяти MOV, LW/SW, можно считывать различные данные от устройства,
включая его состояние.

Методы ввода/вывода:
1) Активное ожидание/Опрос. Перед каждой пересылкой данных к контроллеру внешнего устройство операционная система считывает со специального регистра устройства
его состояние, которое можно охарактеризовать как готово/не готово.

На псевдокоде данный метод можно описать как:

volatile u32 *data_register   = (volatile u32 *) <Адрес регистра, куда записываются данные>;
volatile u32 *status_register = (volatile u32 *) <Адрес регистра, откуда можно считать состояние устройства>;
while (*status_register != READY);
*data_register = <Записываемые данные>;

2) Ввод/вывод, управляемый прерываниями. Вместо того чтобы ожидать устройство на готовность, контроллер данного устройства программируется
операционной системой таким образом, чтобы инициировать прерывание CPU по завершении операции -- готовности устройства. Таким образом, циклы CPU
не расходуются впустую. При наступлении прерывания CPU останавливает выполнение текущей задачи и переходит к выполнению специальной процедуры,
называемой обработчиком прерывания.

На псевдокоде данный метод можно описать как:

Начальный запрос устройства:

volatile u32 *data_register   = (volatile u32 *) <Адрес регистра, куда записываются данные>;
volatile u32 *status_register = (volatile u32 *) <Адрес регистра, откуда можно считать состояние устройства>;
volatile u32 *interrupt_register = (volatile u32 *) <Адрес регистра, управляемого генерацией устройством прерываний CPU>;
*interrupt_register = ENABLE_INTERRUPTS;    /* Включаем прерывания на контроллере внешнего устройства */
enable_cpu_interrupts();                    /* Включаем прерывания на CPU */
while (*status_register != READY);
*data_register = <Записываемые данные>;

Обработчик прерывания:

volatile u32 *data_register   = (volatile u32 *) <Адрес регистра, куда записываются данные>;
acknowledge_interrupt();                    /* Посылка контроллеру прерывания информации о завершении обработки прерывания */
return_from_interrupt();

3) Ввод/вывод с использованием DMA.

CPU конфигурирует контроллер DMA, либо принадлежащий самому устройству, либо выступающий в качестве самостоятельного устройства, таким образом, чтобы:
 * был осуществлен трансфер заданного буфера оперативной памяти в устройство;
 * по окончании трансфера было инициировано прерывание CPU.

На псевдокоде данный метод выглядит следующим образом:

Начальный запрос устройства:

set_up_DMA_controller();

Обработчик прерывания:

acknowledge_interrupt();
return_from_interrupt();

Драйвера внешних устройств.

__Драйвер__ - программа, управляющая работой внешнего устройство через взаимодействие с его контроллером.
В своей работе драйвер использует описанные выше методы ввода/вывода, а также MMIO.

Драйвера входят в состав ядра операционной системы и имеют с ним чётко обозначенный интерфейс, зависящий от
подсистемы ядра, в которую входит драйвер (сетевая подсистема, подсистема PCI и т. п.).

Любой драйвер имеет в своем составе функцию инициализации, в которой:
 * происходит проверка присутствия нижележающего оборудования с помощью запросов через MMIO;
 * происходит идентификация оборудования (через чтение специализированных регистров устройства);
 * в случае если оборудование присутствует и поддерживается драйвером, происходит обращение к ядру операционной системы
 для установки обработчика прерывания от устройства.
 * драйвер регистрирует себя в подсистеме ядра; таким образом, он становится доступен пользовательскому пространству.

################################################################################

53. Управление файловыми системами: организация дискового пространства, современные файловые системы.

__Файловая_система__ - способ хранения файлов на долговременном носителе.
__Файл__ - именованная последовательность байт, хранящаяся на долговременном носителе.

Организация дискового пространства.

Цель организации дискового пространства - эффективное отслеживание соответствие файлов блоков на диске.

Расположение файлов:

1) Непрерывное размещение. Файлы располагаются на долговременном носителе информации
в виде непрерывной последовательности блоков.
Таким образом, при размере блока 512 байт, файл размером 10 Кб займет на диске 20 последовательных блоков.


      Файл A (4 блока)   Файл B (3 блока)           Файл C (6 блоков)
            |                    |                         |
            |                    |                         |
 ----  ----  ----  ----  ----  ----  ----  ----  ----  ----  ----  ----  ---- 
|++++||++++||++++||++++||@@@@||@@@@||@@@@||++++||++++||++++||++++||++++||++++| ...
|++++||++++||++++||++++||@@@@||@@@@||@@@@||++++||++++||++++||++++||++++||++++| ...
 ----  ----  ----  ----  ----  ----  --- - ----  ----  ----  ----  ----  ---- 

Пример организации хранилища показан на диаграмме выше. Здесь следует заметить, что каждый следующий файл записывается сразу после предыдущего.
Следует заметить также, что каждый новый файл начинается от границы нового блока. Поэтому, если фактически файл A занимает 3,5 блоков, то
пространство будет потеряно впустую (фрагментация).

При удалении блоки, занимаемые файлов, помечаются как свободные. Перемещение файлов не производится, поскольку может занимать значительное время.
Фрагментация неизбежна.

2) Размещение с использованием связанного списка. Представление каждого файла в виде связанного списка дисковых блоков.
При этом первое слово каждого блока используется в качестве указателя на следующий дисковый блок, а вся остальная часть блока предназначена для хранения данных.


                                     ФАЙЛ A.

         --------      --------      --------      --------      --------
        |        |--->|        |--->|        |--->|        |--->|  NULL  |    
        |        |    |        |    |        |    |        |    |        |    
         --------      --------      --------      --------      --------     
        |        |    |        |    |        |    |        |    |        |    
        | Блок 0 |    | Блок 1 |    | Блок 2 |    | Блок 3 |    | Блок 4 |    
        |        |    |        |    |        |    |        |    |        |    
        | файла  |    | файла  |    | файла  |    | файла  |    | файла  |    
        |        |    |        |    |        |    |        |    |        |    
        |        |    |        |    |        |    |        |    |        |    
         --------      --------      --------      --------      --------     

Физический  4             7              2            10            12
  блок


                                     ФАЙЛ B.

         --------      --------      --------      -------- 
        |        |--->|        |--->|        |--->|  NULL  |
        |        |    |        |    |        |    |        |
         --------      --------      --------      -------- 
        |        |    |        |    |        |    |        |
        | Блок 0 |    | Блок 1 |    | Блок 2 |    | Блок 3 |
        |        |    |        |    |        |    |        |
        | файла  |    | файла  |    | файла  |    | файла  |
        |        |    |        |    |        |    |        |
        |        |    |        |    |        |    |        |
         --------      --------      --------      -------- 

Физический  6             3             11            14
  блок

В отличие от непрерывного хранения файлов, в этом методе может быть использован каждый дисковый блок.
При этом потери дискового пространства на фрагментацию отсутствуют (за исключением внутренней фрагментации в последнем блоке).
Кроме того, достаточно, чтобы в записи каталога хранился только дисковый адрес первого блока. Всю остальную информацию
можно найти начиная с этого блока. В то же время доступ к файлам, хранящимся подобным образом осуществляется медленее,
чем к последовательно хранимым файлам.

3) Размещение с использованием связанного списка, использующего таблицу в памяти (FAT, File Allocation Table).
Развитие второго метода, при котором указатели хранятся на долговременном носителе информации в виде массива,
где индекс элемента равен номеру физического блока.
При инициализации файловой системы данная таблица загружается в оперативную память, за счёт
чего можно быстро вычислить требуемый физический блок.

  Физический
     блок
          ----------
        0 |        |
          ----------
          ----------
        1 |        |
          ----------
          ----------
        2 |   10   |
          ----------
          ----------
        3 |   11   |
          ----------
          ----------
        4 |    7   |  <---- ФАЙЛ A НАЧИНАЕТСЯ ЗДЕСЬ.
          ----------
          ----------
        5 |        |
          ----------
          ----------
        6 |    3   |  <---- ФАЙЛ B НАЧИНАЕТСЯ ЗДЕСЬ.
          ----------
          ----------
        7 |    2   |
          ----------
          ----------
        8 |        |
          ----------
          ----------
        9 |        |
          ----------
          ----------
       10 |   12   |
          ----------
          ----------
       11 |   14   |
          ----------
          ----------
       12 |   -1   |
          ----------
          ----------
       13 |        |
          ----------
          ----------
       14 |   -1   |
          ----------
          ----------
       15 |        |  <---- НЕИСПОЛЬЗУЕМЫЙ БЛОК.
          ----------

Существенным недостатком данного метода является прямая пропорциональность
дополнительно требуемой памяти объему памяти долговременного носителя информации.
При больших объемах памяти долговременного носителя информации данный
метод неприменим.

3) I-узлы (inodes). С каждым файлов связывается i-узел. При этом i-узлы всех файлов
не обязательно должны хранится в оперативной памяти одновременно.
I-узел (inode) - специальная структура данных, содержащая атрибуты файлов, а также дисковые адреса его блоков.
Схема i-узла:

          ----------------------------
	  |                          |
          |      Атрибуты файла      |
	  |                          |
          ----------------------------
          ----------------------------
          |      Адрес блока 0       | ------>
          ----------------------------
          ----------------------------
          |      Адрес блока 1       | ------>
          ----------------------------
          ----------------------------
          |      Адрес блока 2       | ------>
          ----------------------------
          ----------------------------
          |      Адрес блока 3       | ------>
          ----------------------------
          ----------------------------
          |      Адрес блока 4       | ------>
          ----------------------------
          ----------------------------
          |      Адрес блока 5       | ------>
          ----------------------------
          ----------------------------
          |      Адрес блока 6       | ------>
          ----------------------------
          ----------------------------
          |      Адрес блока 7       | ------>
          ----------------------------
          ----------------------------         ----------------
          |  Адрес блока указателей  | ------> |              |
          ----------------------------         |  Блок диска  |
	                                       |  содержащий  |
					       |дополнительные|
					       |   дисковые   |
					       |    адреса    |
					       |              |
					       ----------------

Многие файловые системы UNIX, а также NTFS используют именно
этот способ хранения информации на долговременном носителе.

################################################################################

54. Сетевые возможности современных операционных систем:
архитектура сетевых операционных систем, реализация операционных систем для различных типов компьютерных сетей, сетевые службы.

__Сетевая_операционная_система__ - операционная система, поддерживающая работу по компьютерной сети.
Примеры сетевых ОС: Linux, Windows.

Архитектура сетевой операционной системы.

0) На самом нижним уровне выступают драйвера сетевых карт.
Драйвера коммуницируют с сетевой картой посредством специальных структур данных - дескриптора.
Схема типового дескриптора изображена ниже:

        --------------------
	| Физический адрес |
	|   передаваемых   |
	|      данных      |
	--------------------
	--------------------
	|   Длина пакета   |
	|         +        |
	|       флаги      |
	--------------------
        --------------------
	| Физический адрес |
	|   следующего     |
	|   дескриптора    |
	--------------------
	|                  |
	|                  |
	~   Выравнивание   ~
	~  (игнорируется)  ~
	|                  |
	|                  |
	--------------------

Каждый дескриптор содержит указатель на следующий.
Совокупность дескрипторов образует кольцевой односвязный список.
Именно через дескрипторы происходит приём/отправка пакетов по физическому носителю (витая пара, радиоэфир и т.п.)

1) Обработка данных на канальном уровне. Реализуется совместными усилиями драйвером сетевого устройства и
интерфейса ядра между сетевым стеком и драйвером сетевого устройства. На данном уровне проверяется, что
mac-адрес узла-получателя совпадает с mac-адресом сетевой платы, на которую пришел пакет.
Также определяется протокол верхнего уровня (сетевого): arp, ipv4, ipv6 и т. п.
Организуется передача полученного пакета модулю ядра, реализующего протокол сетевого уровня.
При отправке происходит заполнение заголовка канального уровня и передача его драйверу сетевого устройства.

2) Обработка данных на сетевом уровне. Реализуется модулем ядра - реализацией сетевого протокола.
На данном уровне происходит анализ сетевого адреса назначения, а также определения дальнейшего пути пакета:
 * input -- пакет предназначен для текущего хоста на сетевом уровне.
 * output -- пакет сгенерирован текущим хостом и должен быть передан драйверу сетевого устройства.
 * forward -- пакет предназначен другому хосту, путь до которого содержится в таблицах маршрутизации текущего хоста.
В соответствии с определённым назначением, пакет либо передается протоколу верхнего уровня (tcp/udp, icmp),
либо передается драйверу сетевого устройства для отправки (output, forward).

3) Обработка данных на транспортном уровне. Реализуется модулем ядра - реализацией транспортного протокола.
На данном уровне происходит контроль целостности передаваемых/получаемых данных (за счёт подтверждения полученных пакетов - для tcp),
ликвидация дубликатов,
а также контроль порядка (за счёт нумерации отправляемых пакетов в заголовке транспортного уровня - tcp).
При получении пакета ищется задача, его ожидающая (задача, которой принадлежит сокет).
Если задача найдена, то происходит переключение задачи в состояние готовности, а также передача ей полученных данных.

4) Интерфейс сокетов. Является интерфейсом пользовательского пространства
к сетевым возможностям операционной системы. Реализуется через механизм системных вызовов.

Интерфейс традиционно включает в себя следующие примитивы:

  * socket -- создает в пространстве ядра сокет, принадлежащий определённому протоколу
  (address family), возвращает целое число, идентифицирующее созданный сокет
  (в Linux - файловый дескриптор);
  * bind -- связывает сокет с сетевым адресом; адрес может включать в себя как
  сетевой адрес (IP-адрес), так и транспортный адрес (номер TCP/UDP порта);
  * listen -- для протоколов, ориентированных на соединение (TCP), разрешает приём
  входящих соединений к данному сокету;
  * accept -- ожидает подключения (tcp), после чего возвращает файловый дескриптор, с помощью
  которого можно взаимодействовать с подключившейся стороной;
  * connect -- инициирует соединение к хосту с заданным адресом (для tcp);
  * send -- отправляет данные по сети;
  * recv -- получает данные по сети;
  * close -- закрывает сокет, разрывая установленные соединения и завершая текущие операции.

Сетевые службы.

Программы пользовательского окружения, использующие сетевые возможности операционной системы
(интерфейс сокетов), называются сетевыми службами. Примеры сетевых служб:
  * DHCP клиент;
  * WEB-сервер;
  * Браузер;
  * NTPD -- демон, реализующий протокол ntp (синхронизация часов).

################################################################################

83.	Протокол SSL
Отличная статья от ИТМО:
https://neerc.ifmo.ru/wiki/index.php?title=SSL/TLS

################################################################################

84.	Протокол Kerberos
Kerberos — сетевой протокол аутентификации, позволяющий передавать данные через незащищённые сети для обеспечения безопасной идентификации. Ориентирован, в первую очередь, на клиент-серверную модель и обеспечивает взаимную аутентификацию — оба пользователя подтверждают личности друг друга через доверенный сервер. Данная модель является одним из вариантов протокола аутентификации Нидхема — Шрёдера на основе доверенной третьей стороны.

@Общие сведения:
-	протокол Kerberos был специально разработан для того, чтобы обеспечить надежную аутентификацию пользователей;
-	предусматривается, что начальный обмен информацией между клиентом и сервером происходит в незащищённой среде, а передаваемые пакеты могут быть перехвачены и модифицированы;
-	протокол Kerberos может использовать централизованное хранение аутентификационных данных и является основой для построения механизмов Single Sign-On (возможность использования единой учетной записи пользователя для доступа к любым ресурсам области);
-	протокол основан на понятии Ticket (билет). Ticket (билет) является зашифрованным пакетом данных, который выдается доверенным центром аутентификации, в терминах протокола Kerberos — Key Distribution Center (KDC, центр распределения ключей);
-	когда пользователь выполняет первичную аутентификацию, после успешного подтверждения его подлинности KDC выдает первичное удостоверение пользователя для доступа к сетевым ресурсам — Ticket Granting Ticket (TGT). В дальнейшем, при обращении к отдельным ресурсам сети, пользователь, предъявляя TGT, получает от KDC удостоверение для доступа к конкретному сетевому ресурсу — Service Ticket (TGS);
-	одним из преимуществ протокола Kerberos, обеспечивающим высокий уровень безопасности, является то, что при любых взаимодействиях не передаются ни пароли, ни значения хеша паролей в открытом виде;
-	работая с протоколом Kerberos, необходимо, чтобы системные часы всех участвующих во взаимодействии узлов были синхронизированы;
-	в качестве примера реализации протокола Kerberos имеет смысл отметить доменную аутентификацию пользователей в операционных системах Microsoft, начиная с Windows 2000.

@Процесс работы с протоколом Kerberos (кратко):
Пользователь регистрируется на своей рабочей станции, которая обрабатывает последовательность сообщений AS_REQ и AS_REP с центром KDC, откуда пользователь получает билет TGT, если учетные данные верны. Затем TGT пользователя кэшируется в памяти, и каждый раз, когда пользователю нужно получить доступ к службе (например, к серверу файлов, серверу печати, веб-приложению), пользователь предъявляет TGT центру KDC и запрашивает билет службы для конкретной службы. Пользователь получает билет службы и предъявляет его приложению, чтобы запросить доступ.
Схематично:
 ___________________                    ___________________                    ___________________
|                   |                  |                   |                  |                   |
|                   |                  |                   |>>>  1 AS_REQ  >>>|                   |
|       Сервер      |<<<  5 AP_REQ  <<<|       Клиент      |<<<  2 AS_REP  <<<|        KDC        |
|     приложений    |>>>  6 AP_REP  >>>|                   |>>>  3 TGS_REQ >>>|     (AS + TGS)    |
|                   |                  |                   |<<<  4 TGS_REP <<<|                   |
|___________________|                  |___________________|                  |___________________|

AS	==	Authentication Server
TGS	==	Ticket Granting Server
В процессее повествования отмечаю оба сервера как один - KDC, но на практике они могут рассматриваться как различные: в таком случае за процесс аутентификации отвечает сервер AS, а процесс выдачи билетов обеспечивает TGS. Просто заметка)

@Проверка подлинности:
-	после того, как пользователь вводит имя и пароль на клиентской машине, эта машина хеширует введенный пароль. Полученный хеш становится секретным ключом клиента;
-	для проверки подлинности введенных данных в KDC отправляется сообщение AS_REQ (Authentication Service Request). Для защиты от атаки с повторной передачей пакетов текущее время шифруется с использованием хеша пароля пользователя. Допустимое расхождение времени при этом (по умолчанию) - 5 минут. Элементы запроса AS_REQ представлены ниже:
   ___________________________
  |                           |
  |   ----------------------  |
  |  |     Имя клиента      | |
  |   ----------------------  |
  |  |  Имя службы(krbtgt)  | |
  |   ----------------------  | 
  |  #  Время клиента(шифр.)# |
  |   ----------------------  |
  |___________________________|
              AS_REQ
            
-	когда KDC получает запрос AS_REQ, он в первую очередь пытается расшифровать отметку времени с использованием локальной копии хеша пароля пользователя. Если попытка заканчивается неудачей, клиент получает сообщение об ошибке, и обработка запроса прекращается. Если расшифрование происходит удачно И значение отметки времени находится в допустимых пределах, KDC отправляет пользователю сообщение AS_REP (Authentication Service Reply) со встроенным билетом TGT (Ticket Granting Ticket). Ответ AS_REP содержит в себе имя пользователя и два блока зашифрованных данных: первый блок шифруется с применением хеша пароля пользователя и содержит сеансовый ключ и отметку времени окончания существования билета (10 часов по умолчанию); а второй блок шифруется при помощи секрета KDC, который хранится в Active Directory как пароль для учетной записи krbtgt. Элементы ответа AS_REP представлены ниже:

 ____________________________________
|       -----------------------      |
|      |      Имя клиента      |     |
|       -----------------------      |
|   ------------------------------   |
|  #                              #  |
|  #    ------------------------  #  |
|  #   |       Ключ сессии      | #  |
|  #    ------------------------  #  |
|  #   | Время жизни/истечения  | #  |
|  #    ------------------------  #  |
|  #                              #  |
|   ------------------------------   |
|                                    |
|   ------------------------------   |
|  $                              $  |
|  $    ------------------------  $  |
|  $   |       Ключ сессии      | $  |
|  $    ------------------------  $  |
|  $   |   Информация маркера   | $  |
|  $    ------------------------  $  |
|  $   | Время жизни/истечения  | $  |
|  $    ------------------------  $  |
|  $               TGT            $  |
|   ------------------------------   |
|____________________________________|    
                AS_REP

Сеансовый ключ используется для шифрования будущих соединений с центром KDC. После получения AS_REP компьютер сохраняет в кэше билет TGT и сеансовый ключ на время существования TGT, а затем удаляет хеш пароля пользователя.

@Получение билета службы:
-	в Kerberos любой объект, к которому требуется получить доступ, называется службой (например, серверы файлов и печати, серверы базы данных, внутренние веб-приложения). Для доступа к службе пользователь предоставляет билет службы. Перед этим компьютер или приложение пользователя определяет имя участника службы service principal name (SPN), к которой нужно получить доступ.
-	для получения билета службы клиент обращается к KDC, отправляя ему запрос TGS_REQ (Ticket Granting Service Request). Первый фрагмент информации в запросе - имя SPN службы, для которой клиент запрашивает билет. Второй фрагмент - имя клиента и отметка текущего времени - шифруются с помощью сеансового ключа, полученного из AS_REP. Третий фрагмент - экземпляр билета TGT, полученного ранее также из AS_REP, зашифрованный при помощи секрета KDC. Элементы запроса TGS_REQ представлены ниже:
 ____________________________________
|       -----------------------      |
|      |           SPN         |     |
|       -----------------------      |
|   ------------------------------   |
|  #                              #  |
|  #    ------------------------  #  |
|  #   |       Имя клиента      | #  |
|  #    ------------------------  #  |
|  #   |     Отметка времени    | #  |
|  #    ------------------------  #  |
|  #                              #  |
|   ------------------------------   |
|                                    |
|   ------------------------------   |
|  $                              $  |
|  $    ------------------------  $  |
|  $   |       Ключ сессии      | $  |
|  $    ------------------------  $  |
|  $   |   Информация маркера   | $  |
|  $    ------------------------  $  |
|  $   | Время жизни/истечения  | $  |
|  $    ------------------------  $  |
|  $               TGT            $  |
|   ------------------------------   |
|____________________________________|    
                TGS_REQ

                
-	после получения запроса TGS_REQ KDC проверяет, что указан один элемент для SPN, отметка времени находится в допустимом диапазоне и билет TGT не просрочен. Если все условия выполнены, то клиенту отправляется ответ TGS_REP, содержащий в себе зашифрованный билет службы. Первый блок TGS_REP шифруется при помощи сеансового ключа. Билет службы шифруется с помощью секрета службы (например, пароля учетной записи компьютера или учетной записи службы). Клиент кэширует билет службы и использует всегда, когда необходим доступ к службе. Так же, как у билетов TGT, время, в течение которого разрешено повторно использовать билеты службы, ограничено (десять часов по умолчанию в реализации Kerberos в AD). Имея билет службы, клиент может запросить доступ к ней. Элементы ответа TGS_REP представлены ниже:
 ____________________________________
|   ------------------------------   |
|  #                              #  |
|  #    ------------------------  #  |
|  #   |           SPN          | #  |
|  #    ------------------------  #  |
|  #   |     Отметка времени    | #  |
|  #    ------------------------  #  |
|  #   |   Ключ сессии службы   | #  |
|  #    ------------------------  #  |
|  #                              #  |
|   ------------------------------   |
|                                    |
|   ------------------------------   |
|  $                              $  |
|  $    ------------------------  $  |
|  $   |       Имя клиента      | $  |
|  $    ------------------------  $  |
|  $   |          SPN           | $  |
|  $    ------------------------  $  |
|  $   |   Ключ сессии службы   | $  |
|  $    ------------------------  $  |
|  $   |     Отметка времени    | $  |
|  $    ------------------------  $  |
|  $         Билет службы         $  |
|   ------------------------------   |
|____________________________________|    
                TGS_REP

@Доступ к службам:
-	после того, как клиент получает билет службы, приложение, обращающееся к службе, может предъявить этот билет службе и запросить доступ. Механика предъявления билета службы не так стандартизована, как получение билета, из-за различий, свойственных приложениям. Например, в случае со службой HTTP билет службы встраивается в заголовки запроса HTTP.
-	клиент отправляет запрос AP_REQ, содержащий в себе билет службы. Служба дешифрует билет службы и получает сеансовый ключ, который можно использовать для дешифрации первого блока данных: полей отметки времени и имени клиента, которые в свою очередь используются для проверки подлинности билета службы. Даже если служба принимает билет службы, на данном этапе клиент просто прошел проверку в службе. Выполнить задачу авторизации службе предстоит на основе информации о клиенте.
-	в билет службы также обычно входят данные, известные как сертификат атрибута привилегий Privilege Attribute Certificate (PAC). Это та же информация маркера, которую KDC включает в билет TGT пользователя. Сертификат PAC составлен из такой информации, как идентификатор безопасности (SID) пользователя, сведения о членстве в группе и правах безопасности/привилегиях пользователя. Когда пользователь предъявляет билет TGT в центр KDC, чтобы запросить билет службы, KDC копирует информацию маркера из TGT и вставляет в поле PAC билета службы. Служба использует эту информацию, чтобы подготовить маркер доступа для пользователя и проверить авторизацию пользователя, обычно на основе членства в группе.
-	допускается передача дополнительного сообщения Kerberos, известного как AP_REP или Application Reply, после того как пользователь предъявляет билет службы в сообщении AP_REQ. Сообщение Application Reply — необязательное; как правило, приложение не отправляет такое сообщение, если не происходит ошибки. Пример ситуации, когда формируется сообщение AP_REP: клиент запрашивает (в сообщении AP_REQ) у службы подтверждение подлинности для обоюдной проверки подлинности.
Элементы запроса AP_REQ представлены ниже:


 ____________________________________
|   ------------------------------   |
|  #                              #  |
|  #    ------------------------  #  |
|  #   |       Имя клиента      | #  |
|  #    ------------------------  #  |
|  #   |     Отметка времени    | #  |
|  #    ------------------------  #  |
|  #                              #  |
|   ------------------------------   |
|                                    |
|   ------------------------------   |
|  $                              $  |
|  $    ------------------------  $  |
|  $   |       Имя клиента      | $  |
|  $    ------------------------  $  |
|  $   |          SPN           | $  |
|  $    ------------------------  $  |
|  $   |   Ключ сессии службы   | $  |
|  $    ------------------------  $  |
|  $   |     Отметка времени    | $  |
|  $    ------------------------  $  |
|  $   |   Информация маркера   | $  |
|  $    ------------------------  $  |
|  $         Билет службы         $  |
|   ------------------------------   |
|____________________________________|	
                AP_REQ
 
################################################################################

96. Вредоносные программы: классификация, основные характеристики, современные тенденции в развитии вредоносных программ
Вредоносная программа – программа, используемая для осуществления несанкционированного доступа к информации и (или) воздействия на информацию или ресурсы автоматизированной информационной системы (из ГОСТ 51275-2006 Защита информации. Объект информатизации…).
Классификация вредоносных программ:
1)	Вирус – самовоспроизводящийся программный код, который внедряется в установленные программы без согласия пользователя. В дополнение к этому вирус может быть запрограммирован на выполнение вредоносных действий (например, удаление или порча файлов) и самомодификацию. Примеры: Virus 1, 2, 3, Elk Cloner, «Чернобыль».
2)	Червь – саморазмножающаяся программа, которая поселяется на компьютер жертвы, а затем ищет уязвимости в Сети или системе для дальнейшего распространения себя. Некоторые черви существуют в виде сохраненных на жестком диске файлов, а некоторые поселяются в оперативной памяти компьютера. Примеры: червь Морриса, Stuxnet, Wanna Cry.
3)	Троян – вредоносная программа, которая отличается от самопроизвольно распространяющихся вирусов и червей тем, что она распространяется злоумышленниками. Большинство троянских программ маскируется под безвредные или полезные программы, чтобы пользователь загрузил/установил их на свой компьютер. Злоумышленники помещают троянские программы на открытые и индексируемые ресурсы, носители информации, присылают их предполагаемым жертвам по электронной почте, также трояны устанавливаются на компьютер через бреши безопасности. Примеры: Trojan.Spy, Trojan.Downloader, Trojan.SMS.
4)	Руткит – вредоносная программа, специально разработанная для сокрытия присутствия вредоносного кода  и его действий от пользователя и установленного защитного программного обеспечения. Некоторые руткиты могут начинать свою работу прежде, чем загрузится операционная система (буткит). Примеры: Blue Pill, Haxdoor, Mebroot. 
5)	Бэкдор (средство удаленного администрирования) – приложение, которое позволяет злоумышленнику управлять компьютером на расстоянии. В зависимости от функциональных особенностей конкретного бэкдора, злоумышленник может установить и запустить на компьютере любое программное обеспечение, сохранять все нажатия клавиш, загружать и сохранять файлы, делать снимки с веб-камеры и т.п. Примеры: Linux.Backdoor.*, Python.Backdoor.*, Backdoor:MSIL/Sorcas.A.
6)	Загрузчик – небольшая программа, которая используется лишь для дальнейшей загрузки и установки полной версии вредоносной программы. После того, как загрузчик попадает на компьютер жертвы (например, после открытия вложения из полученного письма), он соединяется с удаленным сервером и загружает всю вредоносную программу. Пример: Nemucode.
7)	Вредоносные утилиты – программы, разработанные для автоматизации создания других вредоносных программ, организации DoS-атак на удаленные сервера, взлома компьютеров и т.д. В отличие от предыдущих категорий, такие программы не представляют угрозы компьютеру, на котором исполняются. Примеры: Email-Flooder, DoS, Spoofer.
8)	Нежелательное ПО – программы, которые по своей сути не являются вредоносными, но в большинстве случаев могут надоедать пользователю. Примеры: AdWare, SpyWare, zip-bomb.

Основные характеристики вредоносных программ:
−	целевая среда. Устройства, операционные системы, приложения и т.п.;
−	механизм передачи. Съемные носители, общие сетевые диски, сеть, электронная почта и т.п.;
−	вредоносные действия. Порча, уничтожение, хищение информации, отказ в обслуживании и т.п.;
−	механизмы активации. Ручной (социальная инженерия), полуавтоматический, автоматический (в том числе по событию);
−	механизмы защиты. Обфускация, упаковка, генерация мусора, олигоморфизм, полиморфизм, метаморфизм, обратные атаки на антивирусное программное обеспечение.

Современные тенденции в развитии вредоносных программ:
−	использование техники «living off the land». Злоумышленники, чтобы избежать обнаружения, всё чаще используют программы, которые уже установлены у жертв. Так, например, NotPetya распространялся по сети благодаря утилите PSExec и инструментария управления Windows (WMI). Эти инструменты не классифицируются как угрозы, потому что являются легитимным программным обеспечением, и поэтому не детектируются сканерами;
−	использование «plug-and-play» червей. Злоумышленники после инцидента с WannaCry стали намного чаще полагаться на возможности распространения червей по сети и их последующее закрепление в системе путем планирования задач и формирования бэкдоров;
−	использование аппаратных уязвимостей для проведения атак. После обнаружения уязвимостей Meltdown и Spectre, позволяющих вредоносным приложениям получать доступ к конфиденциальным данным из памяти, злоумышленники выделили их в качестве приоритетных. По материалам ЛК, отдельные APT группировки уже тестируют образцы вредоносных программ, использующих эти уязвимости. 
Дополнительно можно рассказать про внимание к IoT устройствам и увеличению количества вредоносных программ для мобильных устройств.

################################################################################

97. Компьютерные вирусы: классификация, основные характеристики, способы внедрения в программный код, способы сокрытия факта заражения и основные демаскирующие признаки
Компьютерный вирус – самовоспроизводящийся программный код, который внедряется в установленные программы без согласия пользователя. В дополнение к этому вирус может быть запрограммирован на выполнение вредоносных действий (например, удаление или порча файлов) и самомодификацию.

Классификация вирусов:
1)	По целевой среде
-	компьютерные вирусы для различных аппаратных платформ (вирусы для определенной аппаратной платформы, межплатформные вирусы, платформно-независимые вирусы (вирусы виртуальных машин – Java-вирусы, .NET-вирусы));
-	компьютерные вирусы для различных операционных систем (вирусы для определенных ОС, переносимые вирусы (за счет бинарной совместимости ОС, за счет переносимости исходного кода, например, скрипт-вирусы)).
2)	По объекту-носителю
-	вирусы для исполняемых файлов (COM-вирусы, EXE-вирусы (различают MZ-, PE-вирусы), COFF/ELF-вирусы);
-	вирусы для исполняемых объектов (COM/ActiveX-вирусы, Java-вирусы, .NET-вирусы);
-	загрузочные вирусы;
-	скрипт-вирусы;
-	макровирусы;
-	комбинированные.

Выбор объекта-носителя может происходить следующим образом:
-	произвольная жертва (заражется всё подряд);
-	по определенным критериям (заражение происходит, например, только определенных ОС);
-	только конкретные объекты (например, только PE-файлы).
3)	По способу заражения
-	классические вирусы (внедряются в объект-носитель, стараясь максимально скрыть своё присутствие);
-	"вандалы" (внедряются в объект-носитель, не стараясь скрыть своё присутствие, могут повредить объект-носитель);
-	"спутники" (существуют в виде отдельного объекта "рядом" с носителем, заражения как такового не происходит).
4)	По принципу выбора жертвы
-	вирусы-сканеры (определяют жертву в момент своей активации);
-	вирусы-мониторы (отслеживают активность потенциальных объектов-носителей с целью определения возможности заражения).
5)	По размещению в системе
-	резидентный вирус при заражении компьютера оставляет в оперативной памяти свою резидентную часть, которая потом перехватывает обращение операционной системы к объектам заражения (файлам, загрузочным секторам дисков и т.п.) и внедряется в них. Резидентные вирусы находятся в памяти и являются активными вплоть до выключения или перезагрузки компьютера;
-	нерезидентный вирус не заражает память компьютера и является активным ограниченное время. Активизируется в определенные моменты, например, при обработке документов текстовым редактором.
6)	По способу активации
-	ручная (социальная инженерия);
-	автоматическая (характерная для загрузочных вирусов, а также для файловых вирусов с возможностью автозапуска программы);
-	полуавтоматическая (характерная для "спутников");
-	логические бомбы (по наступлению определенного события);
-	временные бомбы (по наступлению определенного момента времени).
7)	По способу защиты от удаления
-	незащищенные вирусы;
-	зашифрованные вирусы (в том числе упаковка);
-	размазывание вируса (записывается в свободные участки объекта-носителя с использованием переходов);
-	обфускация;
-	олигоморфизм (низкий уровень защиты от сигнатурного поиска);
-	полиморфизм (средний уровень защиты от сигнатурного поиска);
-	метаморфизм (высокий уровень защиты от сигнатурного поиска);
-	активная защита (нападение на антивирусные средства, дополнительные средства от анализа).

Способы внедрения в программный код:
-	размещение X-кода поверх оригинальной программы (затирание);
-	размещение X-кода в свободном месте программы (интеграция);
-	дописывание X-кода в начало, середину или конец файла с сохранением оригинального содержимого;
-	размещение X-кода вне основного тела файла-носителя (например, в динамической библиотеке или NTFS-потоке), загружаемого "головой" X-кода, внедренной в файл способами 1-3.

Способы сокрытия факта заражения:
-	стелс-вирусы. При попытке чтения зараженного сектора диска эти вирусы "подставляют" вместо себя незараженный оригинал;
-	обфускация. Код вируса обрабатывается таким образом, что его становится сложно анализировать исследователю, но функциональность при этом сохраняется;
-	упаковка. Тело вируса сжимается и исполняется только после распаковки декриптором, который прикрепляется к упакованному телу вируса (примеры: UPX, ASpack);
-	генерация мусора. Код вируса "разбавляется" бесполезными инструкциями, которые затрудняют его анализ и мешают сигнатурному анализу;
-	пермутация. Перестановка логических блоков в теле вируса;
-	полиморфизм. Для упаковки вируса каждый раз используется новый ключ, зависимый, например, от объема файла, который он инфицирует;
-	метаморфизм. То же, что и полиморфизм, но в каждом поколении вирусов генерируется новый код декриптора, что мешает сигнатурному анализу;
-	"антипесочница". Вирус не проявляет (либо проявляет позднее) свои деструктивные свойства, если определяет окружающую среду как виртуальную.

Основные демаскирующие признаки:
-	наличие нетипичного стартового поведения в момент загрузки программы;
-	наличие известных сигнатур (в том числе строковые, который явно выдают присутствие вируса);
-	нетипичный набор секций, измененные имена секций;
-	нетипичные таблицы импорта.

################################################################################

98.	Антивирусные программы: классификация антивирусных программ, способы обнаружения и уничтожения вредоносного кода, характеристика современных антивирусных программ
Антивирусная программа - это программа, предназначенная для противодействия ВПО.

Классификация антивирусных программ:
1)	По средствам блокирования
-	программные;
-	программно-аппаратные.
2)	По размещению в оперативной памяти
-	резидентные (находятся в памяти компьютера и осуществляют автоматическую проверку файлов и происходящих событий);
-	нерезидентные (запускаются по требованию пользователя или по определенному расписанию).
3)	По способу защиты от ВПО
-	программы-детекторы (сканеры). Находят ВПО в оперативной памяти, на внутренних и(или) внешних носителях, выводя сообщение при обнаружении вируса;
-	программы-доктора (фаги). Находят зараженные файлы и "лечат" их, удаляя тело вируса из файла. Среди этого вида программ существуют полифаги, предназначенные для поиска и удаления разнообразных видов ВПО;
-	программы-вакцины (иммунизаторы). Выполняют "иммунизацию" системы (файлов, каталогов), блокируя возможное действие ВПО;
-	программы-ревизоры. Запоминают 
-	программы-мониторы. Начинают свою работу при запуске операционной системы, постоянно находятся в памяти компьютера и осуществляют автоматическую проверку файлов;
-	программы-фильтры. Резидентные программы, которые оповещают пользователя обо всех подозрительных действиях.

В соответствии с "Требованиями к средствам антивирусной защиты" ФСТЭК:
-	тип «А» – средства антивирусной защиты (компоненты средств антивирусной защиты), предназначенные для централизованного администрирования средствами антивирусной защиты, установленными на компонентах информационных систем (серверах, автоматизированных рабочих местах);
-	тип «Б» – средства антивирусной защиты (компоненты средств антивирусной защиты), предназначенные для применения на серверах информационных систем;
-	тип «В» – средства антивирусной защиты (компоненты средств антивирусной защиты), предназначенные для применения на автоматизированных рабочих местах информационных систем;
-	тип «Г» – средства антивирусной защиты (компоненты средств антивирусной защиты), предназначенные для применения на автономных  автоматизированных рабочих местах.
Средства антивирусной защиты типа «А» не применяются в информационных системах самостоятельно и предназначены для использования только совместно со средствами антивирусной защиты типов «Б» и (или) «В». 

Способы обнаружения и уничтожения вредоносного кода:
На территории Российской Федерации деятельность, связанная с обнаружением вредоносных программ и последующим их устранением определяется стандартом ГОСТ Р 51188-98. Согласно этому стандарту, при испытаниях программных средств на наличие вредоносного кода используются две основные группы методов обнаружения: программные и аппаратно-программные. К программным методам относятся:
1)	Сигнатурное сканирование – это один из самых простых методов обнаружения вредоносных программ, которой обычно применяется в первую очередь. Принцип его работы заключается в проверке содержимого анализируемого объекта на предмет наличия в нём сигнатур уже известных угроз. Сигнатурой в данном случае называется некоторая последовательность байт, необходимая и достаточная для однозначной идентификации угрозы. При этом сравнение содержимого исследуемого объекта с сигнатурами может производиться не напрямую, а по их контрольным суммам, что позволяет значительно снизить размер записей в вирусных базах, сохранив при этом однозначность соответствия и, следовательно, корректность обнаружения угроз и лечения инфицированных объектов. Следует отметить, что сигнатурное сканирование может не фиксировать наличие полиморфных вирусов, то есть вредоносных программ, которые способны формировать свой программный код «на лету», уже во время исполнения. Для обнаружения таких угроз существуют другие методы, например, эвристический, который будет рассмотрен далее;
2)	Эвристическое сканирование – метод обнаружения вирусов, нацеленный на обнаружение ранее неизвестных вирусным базам вредоносных программ.  Этот метод сканирования не обеспечивает какой-либо гарантированной защиты от новых, отсутствующих в сигнатурном наборе компьютерных вирусов, что обусловлено использованием в качестве объекта анализа сигнатур ранее известных вирусов, а в качестве правил эвристической верификации – знаний о механизме полиморфизма сигнатур. Работа данного метода основывается на наборе эвристик, то есть предположений, статистическая значимость которых подтверждена опытным путем, о характерных признаках вредоносного и, наоборот, безопасного исполняемого кода. Каждый признак имеет определенный вес, то есть число, показывающее важность и достоверность этого признака. Если признак указывает на наличие вредоносного кода, то вес оценивается как положительный, а если на наличие безопасного кода, то вес оценивается как отрицательный. На основании суммарного веса, характеризующего содержимое объекта, эвристический анализатор вычисляет вероятность содержания в нём неизвестного вредоносного объекта. Если эта вероятность превышает некоторое пороговое значение, то исследуемый объект объявляется вредоносным. Следует отметить, что поскольку этот метод базируется на некоторых эмпирических предположениях, при его использовании существует вероятность ложного срабатывания;
3)	Обнаружение аномалий – метод обнаружения вредоносных программ, основанный на выявлении необычных и подозрительных событий в наблюдаемой системе. Так, например, если программа попробует записать какие-то данные в исполняемый файл, антивирус, использующий этот метод, может отметить зафиксированное действие как небезопасное. В отличие от предыдущих методов, метод обнаружения подозрительного поведения позволяет гарантированно обнаружить совершенно новые вирусы, которых еще нет ни в одной вирусной базе. Однако этот метод также может выдавать большое количество ложных срабатываний, что делает пользователя маловосприимчивым к подобным предупреждениям;
4)	Обнаружение изменений – метод обнаружения вредоносных программ, основанный на выявлении изменений, вызываемых вирусами в системе. Работа данного метода базируется на использовании систем контроля целостности. Программы, использующие метод обнаружения изменений, периодически сканируют содержимое дисков компьютера, записывая в свою базу данных контрольные суммы файлов и критически важных внутренних областей файловых систем. При этом при сканировании новые значения контрольных сумм сравниваются со старыми значениями, и если при сравнении обнаруживаются изменения, программа сообщает об этом пользователю. Этот метод часто используют совместно с сигнатурным и эвристическим анализом, направляя антивирусную программу только на файлы и каталоги, в которых произошли изменения;
5)	Вакцинирование программ – метод обнаружения вредоносных программ, принцип работы которого заключается в присоединении к исполняемому файлу специального модуля контроля, который будет следить за целостностью этого файла. Проверке при использовании данного метода подлежат любые характеристики файла, например, его контрольная сумма. При заражении вредоносной программой вакцинированного файла модуль контроля обнаруживает изменения и сообщает об этом пользователю.

Аппаратно-программные методы основаны на реализации одного или нескольких из указанных выше методов защиты с использованием технических устройств и представляют собой один из самых надежных способов защиты программных средств от вредоносного кода. Имея полный контроль над всеми обращениями к дисковой подсистеме компьютера, аппаратно-программный комплекс при необходимости может не только сообщить о каких-либо нарушениях пользователю, но и заблокировать дальнейшую работу компьютера.

################################################################################

99.	Угрозы информационной безопасности программного обеспечения. Модели безопасности информационных систем.
Угрозами информационной безопасности называются потенциальные источники нежелательных событий, которые могут нанести ущерб ресурсам информационной системы. Безопасность ПО в широком смысле является свойством данного ПО функционировать без проявления различных негативных последствий для конкретной компьютерной системы.

Обобщенная классификация угроз информационной безопасности программного обеспечения КС может выглядеть следующим образом:
-	вредоносные программы - программы, используемые для осуществления несанкционированного доступа к информации и (или) воздействия на информацию или ресурсы автоматизированной информационной системы;
-	программные закладки - программные компоненты, заранее внедряемые в компьютерные системы, которые по сигналу или в установленное время приводятся в действие, уничтожая или искажая информацию, или дезорганизуя работу программно-технических средств;
-	способы и средства, позволяющие внедрять вредоносные программы и программные закладки в компьютерные системы и управлять ими на расстоянии.

В настоящее время одним из наиболее опасных средств информационного воздействия на компьютерные системы является использование вредоносных программ (вирусы, черви, сетевые снифферы...). В качестве основных средств вредоносного (деструктивного) воздействия на КС необходимо, наряду с вредоносными программами, рассматривать алгоритмические и программные закладки.
Алгоритмическая закладка - преднамеренное (или случайное) искажение какой-либо части алгоритма, либо построение его таким образом, что в результате конечной программной реализации этого алгоритма программа будет иметь ограничения на выполнение требуемых функций или вовсе не выполнять их при определенных условиях.
Программная закладка - совокупность операторов и (или) операндов, преднамеренно (или случайно) в завуалированной форме включаемая в состав выполняемого кода программного компонента на любом этапе его разработки. Пример: зашитые в программу учетные данные.

Действия алгоритмических и программных закладок условно можно разделить на три класса:
-	изменение функционирования вычислительной системы (сети);
-	несанкционированное считывание информации;
-	несанкционированная модификация информации, вплоть до ее уничтожения.
Указанные классы воздействий могут пересекаться.

С точки зрения времени внесения программных закладок в программы их можно разделить на две категории:
-	«врожденные», то есть закладки, внесенные при разработке ПО;
-	«приобретенные», то есть закладки, внесенные при испытаниях, эксплуатации или модернизации ПО.

--- Дальше описывается лабуда из ГОСТ Р ИСО/МЭК 15408 ---
Часть 1 "Введение и общая модель" является введением в ИСО/МЭК 15408. В ней определяются общие понятия и принципы оценки безопасности ИТ и приводится общая модель оценки.

Объект оценки - совокупность программного, программно-аппаратного и/или аппаратного обеспечения, возможно сопровождаемая руководствами.
Модель политики безопасности объекта оценки - структурированное представление политики безопасности, которая должна быть осуществлена объектом оценки.
К нарушениям безопасности обычно относят: 
-	раскрытие актива несанкционированным получателем, наносящее ущерб (потеря конфиденциальности);
-	ущерб активу вследствие несанкционированной модификации (потеря целостности);
-	несанкционированное лишение доступа к активу (потеря доступности).

Компонент - наименьшая выбираемая совокупность элементов, на которой могут основываться требования.
Семейство - совокупность компонентов, которые направлены на достижение сходной цели, но отличаются акцентами или строгостью.
Класс – совокупность семейств, объединенных общим назначением.

Компоненты считаются объединенными друг с другом комплиментарно (могут дополнять друг друга) или связью замещения (ужесточение требований безопасности, когда i-ый компонент должен включать в себя все предыдущие).
Содержание компонентов является довольно гибким за счет наличия операций: 
1) итерация: позволяет неоднократно использовать компонент при различном выполнении в нем операций;
2) назначение: позволяет определять параметры;
3) выбор: позволяет выбирать один или более пунктов из перечня;
4) уточнение: позволяет осуществлять детализацию.

Модель безопасности: 
Общие Критерии → Профиль Защиты → Задание по Безопасности

Состав профиля защиты:
1) задача по защите (среда и цели безопасности);
2) чем реализуем защиту;
3) обоснование.

Задание по безопасности: описание функций безопасности в ИС.
Создается для того, чтобы: 
1) конкретизировать функции безопасности конкретной ИС; 
2) предоставить органам аттестации и сертификации средства для проведения проверки ИС на соответствие определенным уровням безопасности.

Недостаток ОК: они направлены на описание требований безопасности информационной системы (оценку этих требований), а основной источник угроз – это сам человек.

################################################################################
100. Функциональные требования безопасности: методика формирования требований, реализация функциональных требований безопасности
Часть 2 "Функциональные компоненты безопасности" устанавливает совокупность функциональных компонентов, предназначенных для использования в качестве стандартных шаблонов, на основе которых следует устанавливать функциональные требования к ОО. ИСО/МЭК 15408-2 содержит каталог функциональных компонентов, систематизированных по семействам и классам.

В ОК представлены две различные категории требований безопасности – функциональные требования и требования доверия.
Функциональные требования безопасности – набор требований к функциям объекта информатизации, отвечающим за безопасность. Можно описать требования к самому программному продукту.
Функциональные требования налагаются на те функции ОО, которые предназначены для поддержания безопасности ИС и определяют желательный безопасный режим функционирования ОО. Функциональные требования определены в части 2 ОК. Примерами функциональных требований являются требования к идентификации, аутентификации, аудиту безопасности, неотказуемости источника (невозможности отказа от факта отправления сообщения).
Предположение безопасности – это набор условий, в котором возможно соблюдение политики безопасности.
ФБО – функции безопасности объекта. Описать в терминах РД ОК среду объекта (персонал, внешние системы, которые взаимодействуют с объектом) нельзя.
Представление класса – комментарий (для каких целей может быть использован).
Семейство конкретизирует значение отдельных функций. Дается уникальное и краткое имя (пример: FAU_GEN – семейство генерации данных аудита безопасности).
Затем определяется структура семейства. Действия по управлению определяют, каким образом можно использовать данное семейство.
Существует 11 функциональных классов:
1)	Аудит
2)	Связь
3)	Криптографическая поддержка
4)	Защита данных пользователя
5)	Идентификация и аутентификация
6)	Управление безопасностью
7)	Приватность
8)	Защита ФБО
9)	Использование ресурсов
10)	Доступ к объекту оценки
11)	Доверенный канал

################################################################################
101. Требования доверия к безопасности информационных систем: методика формирования требований, поддержание доверия к безопасности информационных систем и программных продуктов
В ОК представлены две различные категории требований безопасности – функциональные требования и требования доверия. Доверие – основа для уверенности в том, что продукт или система ИТ отвечают целям безопасности.
Основная концепция ИСО/МЭК 15408 - обеспечение доверия, основанное на оценке (активном исследовании) продукта ИТ, который должен соответствовать определенным критериям безопасности. Активное исследование – это оценка продукта или системы ИТ для определения его свойств безопасности. Оценка является традиционным способом достижения доверия, и она положена в основу ОК. Методы оценки могут, в частности, включать в себя:
а)	анализ и проверку процессов и процедур;
б)	проверку, что процессы и процедуры действительно применяются;
в)	анализ соответствия между представлениями проекта ОО;
г)	анализ соответствия каждого представления проекта ОО требованиям;
д)	верификацию доказательств;
е)	анализ руководств;
ж)	анализ разработанных функциональных тестов и полученных результатов;
и)	независимое функциональное тестирование;
к)	анализ уязвимостей, включающий предположения о недостатках;
л)	тестирование проникновения.

Классы доверия:
1)	Управление конфигурацией (помогает обеспечить сохранение целостности ОО)
2)	Поставка и эксплуатация (определяет требования к мерам, процедурам и стандартам, применяемым для безопасной поставки, установки и эксплуатации ОО, обеспечивая, чтобы безопасность ОО не нарушалась во время его распространения, установки и эксплуатации)
3)	Разработка (определяет требования для пошагового уточнения ФБО, вплоть до фактической реализации)
4)	Руководства (определяет требования, направленные на обеспечение понятности, достаточности и законченности эксплуатационной документации)
5)	Поддержка жизненного цикла (определяет требования доверия посредством принятия для всех этапов разработки ОО четко определенной модели жизненного цикла, включая политики и процедуры устранения недостатков, правильное использование инструментальных средств и методов, а также меры безопасности для защиты среды разработки)
6)	Тестирование (устанавливает требования к тестированию)
7)	Оценка уязвимостей (определяет требования, направленные на идентификацию уязвимостей, которые могут быть активизированы)

Если объект оценки имеет функции безопасности, которые реализуются вероятностными или перестановочными механизмами (такими, как пароль или хэш-функция), то требования доверия могут определять, что заявленный минимальный уровень стойкости согласуется с целями безопасности. От каждой такой функции потребуется соответствие указанному минимальному уровню стойкости или, по меньшей мере, дополнительно определенной специальной метрике.
Степень доверия для заданной совокупности функциональных требований может меняться; это, как правило, выражается через возрастание уровня строгости, задаваемого компонентами доверия. Часть 3 ОК определяет требования доверия и шкалу оценочных уровней доверия, формируемых с использованием этих компонентов. Требования доверия налагаются на действия разработчика, представленные свидетельства и действия оценщика. Примерами требований доверия являются требования к строгости процесса разработки, по поиску потенциальных уязвимостей и анализу их влияния на безопасность.

Иерархическая структура представления требований доверия (класс - семейство - компонент - элемент):
Требования доверия
	- Классы доверия
		- Имя класса
		- Представление класса
		- Семейства доверия
			- Имя семейства
			- Цели
			- Ранжирование компонентов
			- Замечения по применению
			- Компоненты доверия
				- Идентификация компонента
				- Цели
				- Замечания по применению
				- Зависимости
				- Элементы доверия

################################################################################

120. Методы и средства защиты информации в локальных вычислительных сетях от атак канального уровня
Для описания методов и средств защиты информации рассмотрим наиболее распространенные атаки канального уровня:
1)	ARP-spoofing (ARP-poisoning)
Address Resolution Protocol (ARP) – протокол канального уровня, использующийся для установления соответствия между IP-адресом и MAC-адресом машины. Для определения MAC-адреса получателя по IP-адресу хост формирует широковещательный Ethernet-кадр, содержащий ARP-запрос (ARP-Request). Запрос содержит MAC и IP отправителя и IP получателя. Хост, обнаруживший свой IP в поле "сетевой адрес получателя", дописывает свой MAC-адрес и отправляет ARP-ответ (ARP-Reply). Получив искомый MAC-адрес, хост заносит его в ARP-кэш, и в дальнейшем для отправки запросов пользуется полученным адресом.
Недостатком данного протокола является отсутствие проверки подлинности пакетов: как запросов, так и ответов. Злоумышленник, отправляя ARP-ответы без предварительного ARP-запроса, может подменить содержимое ARP-кэша произвольным образом и перехватывать трафик между узлами в пределах одного широковещательного домена.
Способы защиты от атаки ARP-spoofing:
−	использовать статическую ARP-таблицу. Необходимые соответствия адресов добавляются в ARP-таблицу и в дальнейшем не заменяются;
−	использовать VLAN. В случае, когда машины злоумышленника и жертвы будут расположены в разных виртуальных сетях, атака не будет возможна;
−	использовать Packet Filtering ACL на коммутаторах. Например, современные коммутаторы DLINK и CISCO поддерживают инструменты анализа пакетов и фильтрацию по конкретным параметрам. Первый вариант: фильтрация всех ARP-пакетов на всех пользовательских портах, у которых в Sender Protocol Address содержится IP-адрес шлюза, что позволяет защититься от подмены адреса шлюза. Второй вариант: фильтрация всех ARP-пакетов на каждом из пользовательских портов, у которых Sender Hardware Address и Sender Protocol Address отличаются уже известных MAC и IP-адресов, что позволяет защититься еще и от подмены адреса некоторого пользователя.
2)	Атаки MAC-spoofing, MAC-flooding
MAC-spoofing – атака канального уровня, суть которой заключается в изменении MAC-адреса сетевого устройства. Благодаря этому коммутатор начинает отправлять на порт, к которому подключен злоумышленник, пакеты, которые он до этого видеть не мог.
MAC-flooding (переполнение таблицы коммутации) – атака, основанная на том, что таблица коммутации в коммутаторах имеет ограниченный размер. После заполнения таблицы, коммутатор не может более запоминать новые MAC-адреса и начинает отправлять трафик на все порты.
Для защиты от этих атак можно использовать функцию коммутатора Port Security: она позволяет указать список MAC-адресов, которым разрешено передавать данные через порт, и дополнительно позволяет ограничить количество подключений на интерфейсе.
3)	Атаки на DHCP-сервер
К основным атакам этого класса относятся:
−	DoS DHCP-сервера. Злоумышленник может сформировать и послать DHCP-серверу огромное количество DHCP-запросов с разными MAC-адресами. Сервер будет выделять IP-адреса из пула, который через некоторое время закончится, после чего DHCP-сервер не сможет обслуживать новых клиентов. Для защиты от этой атаки используется метод DHCP Snooping, который заключается в сравнении MAC-адреса, указанного в DHCP-запросе, с MAC-адресом, который прописан на порту коммутатора. Если адреса не совпадают – пакет отбрасывается, иначе принимается;
−	«Ложный» DHCP-сервер. Злоумышленник может развернуть свой DHCP-сервер и выдавать свои настройки пользователям сети, обеспечивая себе возможность прослушивания трафика, подделки DNS-ответов и т.д.. Для этого необходимо предварительно вывести из строя легальный DHCP-сервер (например, с помощью DoS), следовательно, защита от атаки будет происходить аналогичным образом.
4)	Атака VLAN hopping
VLAN – виртуальная сеть, хосты в которой взаимодействуют друг с другом так, как если бы они были подключены к одному широковещательному домену, независимо от их физического местоположения. Порты коммутаторов, принадлежащие одной VLAN, могут обмениваться кадрами между собой, но не могут обмениваться кадрами с портами других VLAN. При этом порты, предназначенные для передачи кадров только одной виртуальной сети, называются портами доступа, а порты, предназначенные для передачи кадров нескольких VLAN – магистральными, или «транковыми».
VLAN hopping – общее название для атак, которые предполагают проникновение в VLAN, который до выполнения атаки не был доступен атакующему.
Основной атакой этого класса является атака с использованием Dynamic Trunking Protocol (DTP), когда злоумышленник через свой порт отправляет пакет DTP, в результате чего коммутатор считает этот порт магистральным.
Для создания ЛВС, защищенных от атак этого класса, используются следующие принципы:
−	запретить передачу кадров собственной VLAN по магистральным каналам, а в качестве native VLAN использовать VLAN, специально выделенную для этих целей;
−	не использовать стандартную VLAN 1, особенно для управления сетевым оборудованием;
−	на магистральных портах использовать только необходимые VLAN – VLAN, все прочие запрещать;
−	не использовать одинаковые VLAN на разных коммутаторах;
−	все неиспользуемые порты коммутатора переводить в режим shutdown и определять их в отдельную изолированную VLAN.
5)	Атаки на STP
Протокол Spanning Tree Protocol (STP) предназначен для предотвращения зацикливания пакетов  сети при наличии дублирующих маршрутов. Для этого сначала производится обнаружение коммутаторов, которые связаны между собой. Далее среди них выбирается главный, корневой коммутатор (root bridge), после чего блокируются порты коммутатора, которые создают петли в получившейся топологии.
Для построения древовидной структуры без петель в сети должен быть определен корневой коммутатор, от которого и будет строиться это дерево. В качестве корневого коммутатора выбирается коммутатор с наименьшим значением идентификатора. Идентификатор – это число длиной 8 байт, 6 младших байтов которого составляет MAC-адрес его блока управления, а 2 старших байта конфигурируются вручную, что позволяет администратору сети влиять на процесс выбора корневого коммутатора. Если администратор не вмешается в данный процесс, в качестве корневого будет выбран коммутатор с наименьшим MAC-адресом блока управления. Такой выбор может быть далеко не рациональным, поэтому рекомендуется выбирать корневой коммутатор исходя из топологии сети и назначать ему наименьший идентификатор вручную. Далее для каждого коммутатора определяется корневой порт (root port) – порт, который имеет кратчайшее расстояние до корневого коммутатора. Для каждого логического сегмента сети выбирается назначенный мост (designated bridge), один из портов которого будет принимать пакеты от сегмента и передавать их в направлении корневого коммутатора через корневой порт данного моста.
В процессе атаки злоумышленник может притвориться коммутатором так же, как и в атаке VLAN hopping, и направить в сторону атакуемого коммутатора BDPU-пакет с подделанным приоритетом и MAC-адресом, чтобы в результате самому стать корневым коммутатором и с его помощью перехватывать сетевой трафик.
Для защиты от атак этого класса используются следующие принципы:
−	использовать протоколы семейства STP с целью построения отказоустойчивых ЛВС только при необходимости. По возможности использовать механизмы и протоколы маршрутизации сетевого уровня;
−	административно определять и назначать корневые коммутаторы. Использовать дополнительные механизмы и средства защиты протокола STP (RootGuard, LoopGuard, UplinkFast, UDLD) для предотвращения получения роли корневого коммутатора другими коммутаторами;
−	на портах доступа коммутаторов ЛВС выполнять настройки по предотвращению возможности появления или фильтрации BPDU-пакетов протокола STP (механизмы BPDU Guard и BPDU Filter соответственно), а также выполнять настройки для быстрого включения и защиты корневого коммутатора (механизмы PortFast и RootGuard соответственно).
