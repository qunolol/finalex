1.	Ранг матрицы
http://www.mathelp.spb.ru/book1/rank.htm
http://ru.solverbook.com/spravochnik/matricy/rang-matricy/
http://mozgan.ru/Math/TxtAdjacentMinorsMatrix

################################################################################

2.	Методы решения систем линейных уравнений
http://ru.solverbook.com/spravochnik/reshenie-uravnenij/reshenie-sistem-linejnyx-uravnenij/

################################################################################

36. Принятие решений при разработке программ. Формальное обоснование принятых решений. Вариантный сектор, вариантная сеть

################################################################################

44. Процессоры компании Intel. Архитектура процессоров IA-32. Микроархитектура процессоров Intel.
==============================================================================================================

На примере Sandy Bridge (core i7).

Микроархитектура Sandy Bridge.



                  /\ К общему кэшу 3-го уровня (Symmetric Multi-Processing, SMP)
                  ||
        +---------||-------------------------------------------------------------------+
        |         ||                                                                   |
        |         ||         Подсистема памяти                       Блок исполнения   |
        |         ||                                                                   |
        |   +-----||-------------------------+    +--------------------------------+   |
        |   |     \/                         |    |                                |   |
        |   |   +------------------------+   |    |          +----------+          |   |
        |   |   |                        |   |    |          |   Кэш    |          |   |
        |   |   |  Системный интерфейс   |   |    |  /------>|  данных  |          |   |
        |   |   |                        |   |    |  |       | 1 уровня |          |   |
        |   |   +------------------------+   |    |  |       +----------+          |   |
        |   |              ^                 |    |  |            ^                |   |
        |   |              |                 |    |  |            |                |   |
        |   |              |                 |    |  |            V                |   |
        |   |              v                 |    |  |  +-----------------------+  |   |
        |   |   +------------------------+   |    |  |  |   Целочисленные АЛУ,  |  |   |
        |   |   |      Кэш 2 уровня      |   |    |  |  |  блоки вещественных   |  |   |
        |   |   |                        |<----------/  |  вычислений, буфер    |  |   |
        |   |   |   (Команды и данные)   |   |    |     |       памяти          |  |   |
        |   |   +------------------------+   |    |     +-----------------------+  |   |
        |   |      |                         |    |             ^             |    |   |
        |   +------|-------------------------+    +-------------|-------------|----+   |
        |          |                                            |             |        |
        |          |                                            |             |        |
        |   +------v-------------------------+    +-------------|-------------|----+   |
        |   | +----------+     +----------+  |    |  +--------------------+   |    |   |
        |   | |   Блок   |     |   Кэш    |  |    |  |     Подмена,       |   |    |   |
        |   | | выборки/ |---->|микроопер-|--------->|   Планирование     |   |    |   |
        |   | |декодиро- |     |   аций   |  |    |  |                    |   |    |   |
        |   | |  вания   |     +----------+  |    |  +--------------------+   |    |   |
        |   | +----------+          ^        |    |                           |    |   |
        |   |       ^               |        |    |                           |    |   |
        |   |       |               |        |    |                           |    |   |
        |   |       |               |        |    |  +--------------------+   |    |   |
        |   | +----------+     +----------+  |    |  |       Блок         |   |    |   |
        |   | |   Кэш    |     |   Блок   |<---------|  пересортировки    |<--/    |   |
        |   | |  команд  |<----|прогнози- |  |    |  |                    |        |   |
        |   | | 1 уровня |     | рования  |  |    |  +--------------------+        |   |
        |   | +----------+     |переходов |  |    |                                |   |
        |   |                  +----------+  |    |                                |   |
        |   +--------------------------------+    +--------------------------------+   |
        |                 Блок предварительной                   Контроль исполнения   |
        |                                                                              |
        |                            обработки       с изменением последовательности   |
        +------------------------------------------------------------------------------+

Core i7 состоит из четырех основных блоков:
 * подсистемы памяти;
 * блока предварительной обработки;
 * блока контроля исполнения с изменением последовательности;
 * блока исполнения.

                                   Подсистема памяти.

Каждый процессор Core i7 содержит подсистему памяти с объединённым кэшем второго уровня
(L2), а также логикой доступа к кэшу 3 уровня (L3). Все процессоры совместно используют
общий кэш 3 уровня (SMP) - это "последняя остановка", после которой обращение выходит
за пределы микросхемы центрального процессора и отправляется по шине к внешней памяти.
Объем кэшей L2 в Core i7 составляет 256 Кбайт; они представляют собой 8-входовую (8-way)
ассоциативную кэш-памяти с 64-байтовыми строками (cacheline). Размер общего кэша L3
лежит в диапазоне от 1 до 20 Мбайт. Независимо от размера кэш L3 представляет собой
12-входовый ассоциативный кэш с 64-байтовыми строками. Если запрос к кэшу третьего уровня
не приносит результата, он передается в оперативную памяти по шине DDR.

С кэшем 1 уровня связаны два блока предварительной выборки, не показанные на рисунке выше.
Эти блоки пытаются перенести данные из основной памяти в L1 еще до того, как эти данные
были запрошены. Один блок осуществляет предварительную выборку следующего блока памяти
при обнаружении последовательного "потока" памяти, передаваемого процессору. Второй,
более сложный блок предварительной выборки отслеживает последовательность адресов
операций чтения/записи конкретной программы. Если операции осуществляются с постоянным
шагом, блок заранее выбирает следующий элемент, к которому, скорее всего, обратится
программа.

                              Блок предварительной обработки.

Подсистема памяти связана как с блоком предварительной обработки, так и с кэшем данных L1.
Блок предварительной обработки отвечает за выборку команд из подсистемы памяти, декодирование
их в микрооперации по типу RISC и сохранение в двух кэшах команд. Все команды после выборки
помещаются в кэш команд L1. Размер кэша L1 составляет 32 Кбайт, он представляет собой
8-входовую ассоциативную кэш-память с 64-байтовыми строками (cacheline). В ходе выборки
из кэша L1 команды попадают в декодеры, определяющие последовательность микроопераций,
используемых для реализации команды в конвейере исполнения.

Механизм декодирования связывает устаревший набор команд CISC и современные RISC-команды.

Декодированные микрооперации передаются в кэш микроопераций, называемые кэшем команд L0.
Кэш микроопераций напоминает традиционный кэш команд, но в нем достаточно места для
хранения последовательностей микрокоманд, генерируемых отдельными командами.
Поскольку кэшируются не исходные команды, а декодированные микрооперации, необходимость
в повторном декодировании при последующих исполнениях команды отпадает.

Прогнозирование переходов также выполняется в блоке предварительной обработки.
Блок прогнозирование должен "угадать", когда ход выполнения программы отклонится
от строго последовательной выборки, причем он должен сделать это задолго до исполнения
команд перехода. Блок прогнозирования переходов отслеживает результаты
предыдущих переходов и использует эту информацию для новых прогнозов. Детали реализации
блока прогнозирования переходов держатся в секрете.

              Планировщик (контроль исполнения с изменением последовательности).

Команды передаются из кэша микроопераций планировщику команд в порядке, определяемом
программой, но при их исполнении возможно отсутпление от этого порядка. Обнаружив
микрооперацию, которую нельзя исполнить, планировщик удерживает её, одновременно продолжая
обрабатывать поток команд - запускаются все последующие команды, которые не требуют обращения
к занятым ресурсам (регистрам, функциональным блокам и т. д.). Здесь же выполняется подмена
регистров, благодаря чему WAR- и WAW- взаимозависимые команды могут исполняться без задержки.
          ПРИМЕЧАНИЕ: https://en.wikipedia.org/wiki/Hazard_(computer_architecture)
          Write after write (WAW) - инструкция, следующая после текущей, пытается записать операнд,
          прежде чем он записан текущей инструкцией.
          Write after read (WAR) - инструкция, следующая после текущей, пытается записать операнд,
          прежде чем он считан текущей инструкцией.
Хотя очередность выдачи команд может отличаться от предусмотренной в программе,
требование точности прерываний архитектуры Core i7 гласит, что результаты выполнения ISA-команд
(Instruction Set Architecture) должны становиться видимыми программе без отступления от заданной
программой последовательности. За реализацию этого требования отвечает блок пересортировок.

                              Блок исполнения.

Блоки исполнения непосредственно осуществляют целочисленные операции, операции
с плавающей точкой и специализированные команды. Существуют несколько блоков исполнения,
работающих параллельно. Данные они получают из регистрового файла и кэша данных первого
уровня.

                                         Конвейер Sandy Bridge у Core i7.


                                                              ______________________________________________________________
                                                             /                                                              \
                                                             |                                                              |
                                                             V                                                              |
                                                / +--------------------+                    +--------------------+          |
                                                | |    Кэш команд      |                    |                    |          |
                                                | |                    |<-------------------|                    |          |
                                                | |     1 уровня       |                    |                    |          |
                                                | +--------------------+                    |                    |          |
                                                |            |                              |                    |          |
                                                |            |                              |        Блок        |          |
                                     Блок       |            V                              |  прогнозирования   |          |
                                предварительной | +--------------------+                    |     переходов/     |          |
                                  обработки     | |       Блок         |                    |       буфер        |          |
                                                | |                    |                    |      объектов      |          |
                                                | |   декодирования    |                    |      перехода      |          |
                                                | +--------------------+                    |                    |          |
                                                |            |                              |                    | +--------------------+
                                                |            |                              |                    | |                    |
                                                |            V                              |                    | |                    |
                                                | +--------------------+                    |                    | |                    |
                                                | |       Кэш          |                    |                    | |                    |
                                                | |                    |<-------------------|                    | |                    |
                                                | |   микроопераций    |                    |                    | |     Общий кэш      |
                                                \ +--------------------+                    +--------------------+ |                    |          К общему
                                                             |                                                     |                    |--------\   кэшу
                                                             V                                                     |      2 уровня      |--------/ 3 уровня
                  /           +----------------------------------------------------------+                         |                    |
                  |           |                                                          |                         |                    |
     Контроль     |           |              Блок распределения и подмены                |                         |                    |
    исполнения    |           |                                                          |                         |                    |
   с изменением   |           |                                                          |                         |                    |
  последователь-  |           +----------------------------------------------------------+                         |                    |
     ности        |                  |                                            |                                |                    |
                  |                  |                                            |                                |                    |
                  |                  V                                            V                                +--------------------+
                  | +----------------------------+                    +----------------------------+                         ^           
                  | |          Очередь           |                    |          Очередь           |                         |           
                  | |    операций вне памяти     |                    |    операций в памяти       |                         |           
                  | |                            |                    |                            |                         |           
                  \ +----------------------------+                    +----------------------------+                         |           
                         |        |         |                              |         |         |                             |           
                         V        V         V                              V         V         V                             |           
                    +--------++--------++--------+                    +--------++--------++--------+                         |           
                    |        ||        ||        |                    | Cохра- || Загруз-|| Загруз-|                         |           
                    | АЛУ 1  || АЛУ 2  || АЛУ 3  |                    |        ||        ||        |                         |           
                    |        ||        ||        |                    | нение  ||  ка 1  ||  ка 2  |                         |           
                    +--------++--------++--------+                    +--------++--------++--------+                         V           
                         |        |         |                           |    |       |         |                   +--------------------+
                         |        |         |                           |    |       |         \------------------>|                    |
                         V        V         V                           V    \_____  |                             |        Кэш         |
                    +----------------------------------------------------------+   \ \---------------------------->|       данных       |
                    |                                                          |   |                               |      1 уровня      |
                    |                 Блок пересортировки                      |   \------------------------------>|                    |
                    |                                                          |                                   |                    |
                    +----------------------------------------------------------+                                   +--------------------+

На рисунке выше приведена упрощенная схема микроархитектуры Sandy Bridge, в том числе её конвейер.
В верхней части схемы находится блок предварительной обработки, ответственный за выборку команд
из памяти и их подготовку к исполнению. Этот блок получает новые команды x86 из кэша команд
первого уровня. Они декодируются в микрооперации и помещаются в кэш микроопераций, содержащий
приблизительно 1,5К микроопераций.

Если блок декодирования сталкивается с условным переходом, он обращается за информацией к блоку
прогнозирования переходов. Этот блок содержит историю переходов, осуществлявшихся в прошлом,
и на основании накопленных данных предполагает, будет ли выполнен условный переход, когда
он в следующий раз встретится в программе. Здесь используются проприетарные алгоритмы Intel.

Если команда перехода отсутствует в таблице, применяется статическое прогнозирование.
При этом подразумевается, что обратный переход, во-первых, является частью цикла, во-вторых,
по умолчанию предполагается, что он будет выполнен. Точность статического прогноза в этом
случае высока. Прямой переход считается входящим в структуру оператора if и не выполняемым
по умолчанию. Точность статического прогноза в случае прямых переходов значительно ниже,
чем в случае обратных.

Для выбранной ветви целевой адрес определяется по содержимому буфера объектов перехода.
В буфере объектов перехода хранится целевой адрес перехода при последнем выполнении.
Обычно этот адрес правилен (он всегда правилен для переходов с постоянным смещением).
Косвенные переходы осуществляются по разным адресам и их прогнозирование по данным буфера объектов перехода будет ошибочным.

Второй компонент конвейера - логика исполнения с изменением последовательности - получает данные из кэша микроопераций.
При поступлении их блока предварительной обработки каждой последующей микрооперации (за цикл их поступает три)
блок распределения и подмены регистрирует её в таблице, состоящей из 168 записей и называемой буфером переупорядочивания команд.
В этом буфере хранятся данные о состоянии микроопераций, вплоть до пересортировки её результатов.
Затем блок распределения и подмены проводит проверку на предмет доступности ресурсов, необходимых для выполнения микрооперации.
Если ресурсы свободны, микрооперация устанавливается в одну из очередей планировщика.
Для микроопераций, исполняемых в памяти и вне памяти, предусмотрены отдельные очереди.
Если исполнение микрооперации в данный момент невозможно, она откладывается, однако обработка последующих микроопераций продолжается;
таким образом, микрооперации часто исполняются вне их исходной последовательности. Этот принцип позволяет поддерживать загрузку
всех функциональных блоков на максимально высоком уровне. В каждый отдельно взятый момент могут одновременно обрабатываться до 154 команд,
причем 64 из них могут загружаться из памяти, а 36 - сохраняться в памяти.

Иногда микрооперации простаивают. Это происходит в тех случаях, когда к одному и тому же регистру для чтения или записи пытаются
обратиться несколько микроопераций; соответственно, одной из них это удается, а остальным - нет.
Такие конфликты называются WAR и WAW взаимозависимостями. Подмена целевого регистра позволяет записать результаты исполнения
микрооперации в один из 160 временных регистров, а значит, выполнить эту микрооперацию немедленно.
Если же временные регистры недоступны или микрооперация попадает в ситуацию RAW (read after write) взаимозависимости (обойти которую нельзя),
планировщик указывает характер возникшей проблемы в виде записи в буфере переупорядочивания команд.
Впоследствии, после освобождения всех необходимых ресурсов, микрооперация устанавливается в одну из очередей на исполнение.

Очереди планировщика помещают готовые к исполнению операции в один из шести функциональных блоков:
1. АЛУ 1 и блок умножения с плавающей точкой;
2. АЛУ 2 и блок сложения/вычитания с плавающей точкой;
3. АЛУ 3, блок обработки переходов и сравнений с плавающей точкой;
4. Команды сохранения;
5. Команды загрузки 1;
6. Команды загрузки 2.

Три целочисленных АЛУ не одинаковы. АЛУ 1 выполняет любые арифметические и логические операции, умножения и деления.
АЛУ 2 способно выполнять только арифметические и логические операции. АЛУ 3 выполняет арифметические и логические операции,
а также разрешение переходов. Не идентичны и два блока исполнения операций с плавающей точкой.
Первый поддерживает арифметические операции с плавающей точкой, включая умножение, а второй способен
выполнять только сложение и вычитание с плавающей точкой, а также перемещения.

АЛУ и блоки исполнения операции с плавающей точкой получают данные от двух регистровых файлов емкостью по 128 записей.
Один из этих файлов отводится для целых чисел, другой - для чисел с плавающей точкой. В них содержатся все операнды,
необходимые для исполнения команд; кроме того, они играют роль хранилища результатов. В силу подмены регистров,
восемь из них содержат регистры, доступные на уровне архитектуры команд (EAX, EBX, ECX, EDX и т. д.),
однако расположение "реальных" значений в каждом конкретном случае зависит от изменений в отображении, происходящих в ходе исполнения.

Кэш данных первого уровня тесно связан с внутренней конвейерной подсистемой Sandy Bridge. В этом кэше емкостью 32 Кбайта могут храниться целые числа,
числа с плавающей точкой и другие типы данных. В отличие от кэша микроопераций, эти данные никоим образом не декодируются.
Функция кэша данных сводится к хранению копий байтов, находящихся в памяти. Что касается его характеристик, то кэш данных первого уровня
представляет собой 8-входовую ассоциативную кэш-память с емкостью строки 64 байта. Он поддерживает сквозную запись;
иными словами, при изменении строки кэша она незамедлительно копируется обратно в кэш второго уровня (write-through).
В течение цикла кэш данных первого уровня может выполнить две операции чтения и одну операцию записи.
Для реализации множественных обращений используются банки, то есть кэш делится на несколько внутренних кэшей (8 в случае Sandy Bridge).
Если все три обращения относятся к разным банкам, они могут выполняться одновременно; в противном случае одно из обращений к конфликтующим банкам простаивает.
Если затребованное слово не удается обнаружить в кэше первого уровня, отправляется запрос в кэш второго уровня;
последний в такой ситуации либо отвечает сразу, либо обращается к общему кэшу третьего уровня, после чего отвечает.
В любой момент в состоянии исполнения могут находиться до десяти запросов, направленных из кэша первого уровня в кэш второго уровня.

Так как микрооперации исполняются вне исходной последовательности, сохранение в кэше первого уровня возможно только после пересортировки результатов всех команд,
предшествующих команде сохранения. Такую пересортировку результатов с их трассировкой (отслеживанием того, где они находятся) выполняет блок пересортировки.
В случае прерывания прекрашается обработка всех команд, ещё не прошедших пересортировку результатов;
таким образом, обеспечивается соблюдение требования, согласно которому при прерывании должны быть завершены все команды до определённой точки в программе
(точность прерываний).

Если команда сохранения прошла пересортировку результатов, но предшествующие команды ещё обрабатываются, из-за невозможности обновления кэша первого уровня
результаты их исполнения передаются в буфер незавершенных команд. В этом буфере можно единовременно разместить до 36 команд сохранения.
Если одна из последующих команд загрузки попытается считать сохраненные данные, она из буфера незавершенных команд будет перенаправлена непосредственно к команде,
которая в этот момент ещё не помещена в кэш данных первого уровня. Этот процесс называется перенаправлением для загрузки (store-to-load forwarding).

################################################################################

45. Процессоры Intel в реальном режиме: регистры процессора, управление памятью и программами, данные и способы адресации, система команд, система прерываний.

Любой Intel CPU входит в режим реальной адресации памяти (real mode) после сброса (reset).

Модель памяти реального режима Intel CPU.

Программа видит память как набор независимых адресных пространств, называемых сегментами.
Код, данные и стек обычно располагаются в различных сегментах. Чтобы адресовать байт в сегменте,
программа применяет логический адрес, состоящий из сегментного селектора и смещения. Сегментный селектор
определяет сегмент, к которому нужно обратиться. Смещение - байт в адресном пространстве данного сегмента.
В реальном режиме используются сегменты, состоящие из 64 Кбайта каждый. Физический адрес = Сегментный селектор << 4 + Смещение.
CPU не предоставляет какой-либо защиты памяти. Любая программа способна адресовать любой сегмент в пределах 20-битного адресного
пространства, в частности, любая программа способна обращаться к MMIO (взаимодействие с устройствами) и править вектора прерываний.
В реальном режиме размер адреса и операнда по умолчанию равен 16 битам. Префикс "переопределение размера адреса" (67h) может быть использован в реальном режиме,
чтобы включить 32-х битную адресацию. Тем не менее, максимально допустимый 32-х битный линейный адрес (сумма сегментного селектора и смещения) по прежнему равен 0x000FFFFFh.
Префикс "переопределение размера операнда" (66H) позволяет использовать в вычислениях 32-х битные регистры (EAX, EBX, ...), а загружать из памяти двойные слова (4 байта).

        Регистры общего назначения.
        
        31                             0
        +------------------------------+  
        |                              |  EAX
        +------------------------------+  
        |                              |  EBX
        +------------------------------+  
        |                              |  ECX
        +------------------------------+  
        |                              |  EDX
        +------------------------------+  
        |                              |  ESI
        +------------------------------+  
        |                              |  EDI
        +------------------------------+  
        |                              |  EBP
        +------------------------------+  
        |                              |  ESP
        +------------------------------+  
        
        Сегментные регистры.
        
                        15             0
                        +--------------+  
                        |              |  CS
                        +--------------+  
                        |              |  DS
                        +--------------+  
                        |              |  SS
                        +--------------+  
                        |              |  ES
                        +--------------+  
                        |              |  FS
                        +--------------+  
                        |              |  GS
                        +--------------+  
        
        Слово состояния программы и управляющий регистр.
        
        31                             0
        +------------------------------+  
        |                              |  EFLAGS
        +------------------------------+  
        
        Указатель команд.
        
        31                             0
        +------------------------------+  
        |                              |  EIP
        +------------------------------+  

* EAX - аккумулятор для операндов и результатов операций;
* EBX - указатель на данные в сегменте DS;
* ECX - счётчик для операций со строками и циклов;
* EDX - указатель I/O;
* ESI - указатель на данные в сегменте DS; указатель на источник для строковых инструкций;
* EDI - указатель на данные в сегменте ES; указатель на приёмник для строковых инструкций;
* ESP - указатель на вершину стека (в сегменте SS);
* EBP - указатель на данные, хранящиеся в стеке (в сегменте SS).

Сегментные регистры (CS, DS, SS, ES, FS и GS) содержат 16-битные селекторы сегментов. Сегментный
селектор - это специальный указатель, определяющий сегмент в памяти. Для доступа к конкретному сегменту,
сегментный селектор для этого сегмента должен присутствовать в соответствующем сегментном регистре.
В реальном режиме сегментный селектор равен линейному адресу сегмента, делённому на 16.
Каждый из сегментных регистров связан с одним из трёх типов памяти: код, данные и стек.
К примеру, регистр CS содержит сегментный селектор для сегмента кода, где хранятся инструкции,
на данный момент исполняемые CPU. CPU извлекает инструкции из сегмента кода, используя логический адрес,
состоящий из сегментного селектора CS и указателя команд EIP.

Регистры DS, ES, FS и GS указывают на 4 сегмента данных, для их использования в инструкции требуется
специальный префикс переопределения сегмента.

Регистр SS указавает на сегмент стека, все операции со стеком (push*, pop*) используют SS для
нахождения сегмента стека.

32-х битный регистр EFLAGS содержит набор статусных флагов, управляющих флагов, а также системные флаги.

Способы адресации:

1) Непосредственные операнды -- кодирование данных (констант) непосредственно в самой инструкции;
2) Регистровые операнды -- источник или приёмник данных может быть регистром.
3) Операнды в памяти -- данные извлекаются из оперативной памяти (а по факту, из кэша :))
Адрес значения, хранящегося в памяти, формируется следующим образом:

Сегментный селектор -- указывается явно или неявно. Наиболее распространённый способ указания сегментного
селектора - это загрузить его в сегментный регистр и затем позволить процессору обращаться к регистру неявно,
 в зависимости от типа исполняемой инструкции.
Правила выбора сегмента по умолчанию:

+------------------------------+------------------------------+------------------------------+------------------------------+
|   Тип обращения (к памяти)   |    Используемые регистр      |     Используемый сегмент     |       Когда выбирается?      |
+------------------------------+------------------------------+------------------------------+------------------------------+
|Инструкции                    |CS                            |Сегмент кода                  |Любая выборка инструкций      |
+------------------------------+------------------------------+------------------------------+------------------------------+
|Стек                          |SS                            |Сегмент стека                 |Все инструкции push* и pop*   |
|                              |                              |                              |Любые обращения к памяти,     |
|                              |                              |                              |использующие регистры ESP и   |
|                              |                              |                              |EBP в качестве базы           |
+------------------------------+------------------------------+------------------------------+------------------------------+
|Данные                        |DS                            |Сегмент данных                |Любые обращения к данным, за  |
|                              |                              |                              |исключением данных,           |
|                              |                              |                              |относящихся к стеку или       |
|                              |                              |                              |строке-приёмнику              |
+------------------------------+------------------------------+------------------------------+------------------------------+
|Строки-приёмники              |ES                            |Сегмент данных, указываемый   |Приёмники строковых инструкций|
|                              |                              |сегментным регистром ES       |                              |
+------------------------------+------------------------------+------------------------------+------------------------------+

Сегментный регистр, используемый для выбора сегмента, можно изменить, указав специальный префикс "переопределения сегмента".
Следующие правила выбора сегмента по умолчанию не могут быть переопределены:
* Извлечение инструкций должно быть осуществлено из сегмента кода.
* Строки-приёмники могут быть адресованы в строковых операциях только из сегмента ES.
* Операции со стеком (push* и pop*) могут адресовать только сегмент стека SS.

Смещение -- состоит из следующих компонент:
* Сдвиг - 8-, 16-, или 32-х битное значение.
* База - значение, хранящееся в регистре общего назначения.
* Индекс - значение, хранящееся в регистре общего назначения.
* Масштаб - значение, равное 1, 2, 4 или 8, которое умножается на величину "Индекса".
Смещение, получающееся в результате сложения этих компонент, называется эффективным адресом.
Каждый из данных компонент может иметь либо положительное либо отрицательное (дополнение до 2) значение,
за исключением "Масштаба".
Следующая схема описывает способы, которыми компоненты могут быть объединены для формирования
эффективного адреса:

         БАЗА      ИНДЕКС МАСШТАБ     СДВИГ
        /     \     /         \     /       \
        | EAX |     |         |     |       |
        | EBX |     | EAX     |     |  Нет  |
        | ECX |     | EBX   1 |     |       |
        | EDX |  +  | ECX * 2 |     | 8 бит |
        | ESP |     | EDX   4 |     |       |
        | EBP |     | EBP   8 |     |16 бит |
        | ESI |     | ESI     |     |       |
        | EDI |     | EDI     |     |32 бит |
        \     /     \         /     \       /
        
        СМЕЩЕНИЕ=БАЗА+(ИНДЕКС*МАСШТАБ)+СДВИГ

Система команд.

Система команд x86, исполняющихся в реальном режиме, включает в себя следующие категории:
* инструкции общего назначения;
* FPU инструкции.

Инструкции общего назначения осуществляют базовое перемещение данных, арифметические и логические
операции, инструкции перехода, а также строковые операции. Они работают с данными, хранящимися
в памяти, в регистрах общего назначения и в регистре EFLAGS. Также они работают с адресной информацией,
хранящейся в памяти, регистрах общего назначения, а также сегментных регистрах.
Данная группа инструкций включает в себя:
* перемещение данных,
* двоичную целочисленную арифметику,
* двоично-десятичную арифметику,
* логические операции,
* операции сдвига и вращения,
* операции над битами и байтами,
* управление программным потоком,
* строковые операции,
* управление флагами (регистр EFLAGS),
* операции над сегментными регистрами,
* ввод/вывод (IO ports),
* прочие подгруппы.

FPU инструкции.
X87 FPU инструкции исполняются вещественным сопроцессором. Данные инструкции работают с вещественными числами, целыми числами,
а также числами, представленными в двоично-десятичном формате.
Сюда входят такие инструкции как:
* перемещение данных,
* загрузка констант,
* управляющие FPU инструкции,
* арифметические инструкции.

Система прерываний.

Прерывание - асинхронное событие, обычно генерируемое устройством ввода/вывода.
Исключение - синхронное событие, генерируемое процессором в случае обнаружения некоторого условия.

Процессор реагирует на прерывания и исключения одинаково. Когда прерывание или исключение обнаружено,
процессор приостанавливает выполнение текущей программы или задачи и переключается на специализированную
процедуру-обработчика. Процессор обращается к обработчику через запись в специальной таблице, называемой
"таблицей дескрипторов прерываний" (таблица векторов прерываний в реальном режиме). Всего возможно
256 различных прерываний, с номерами от 0 до 255. Некоторые из этих номер зарезервированы архитектурой,
другие же доступны для использования для внешних устройств.

################################################################################

49. Операционные системы: подходы к определению операционной системы как вида программного обеспечения,
функции операционных систем, архитектурные типы, современные тенденции в развитии операционных систем.
==============================================================================================================

__Операционная система__ - вид программного обеспечения, управляющего работой вычислительной системы, а также
расширяющего возможности ЭВМ.

ПОДХОДЫ
1) ОС как расширенная машина.

ОС предоставляет сервисы приложениям пользовательского уровня:
    - Системные вызовы.
    Системные вызовы - это, по сути, механизм, с помощью которого пользовательские приложения запрашивают
    выполнение некоторого действия от ОС. Типичными примерами системных вызовов являются порождение дочернего процесса,
    открытие/закрытие нового файла, запись/чтение в/из файл(а).
    - Абстракции (файлы, сокеты) для доступа к устройствам ввода/вывода.
    Ключевой особенностью является единообразие интерфейса независимо от конкретного оборудования
    (сетевая карта, жёсткий диск). В данном случая ядро (kernel) операционной системы преобразует
    системные вызовы в обращения к конкретным драйверам периферийного оборудования. За счёт этого
    упрощается разработка программного обеспечения.
    - Виртуализация. Концепция "процесса" как программы, исполняющейся на виртуальном процессоре, позволяет предоставить программе
    видение, будто она единолично исполняется на процессоре и в её распоряжении находится всё оперативная память.
    Здесь важно отметить, что без аппаратной поддержки (MMU, прерывания) данные возможности не были бы доступны.
Таким образом, ОС расширяет возможности компьютера, является как бы "новым уровнем" в архитектуре компьютера.

2) ОС как менеджер ресурсов.

В данном подходе считается, что основная задача ОС - упорядоченное и управляемое распределение ресурсов:
    процессора;
    оперативной памяти;
    устройств ввода-вывода
-- между различными программами, претендующими на их использование.

Функции операционных систем:

1) Распределение ресурсов программам -- "процессам": процессорное время, память, устройства ввода/вывода.
2) Управление устройствами компьютера: обслуживание прерываний, конфигурирование оборудование (plug & play).
3) Предоставление сервиса пользовательским приложениям -- выполнение системных вызовов.
4) Виртуализация -- поддержка виртуализации (примеры: VirtualBox, Qemu/KVM)
5) Безопасность -- управление доступом, системы разграничения доступа пользователей, уровни привилегий.
6) Упрощение разработки программного обеспечения -- предоставление библиотек (shared objects), упрощение загрузки программ, облегчение переносимости кода.

Архитектурные типы ("Зоопарк"):

* ОС мейнфреймов
* ОС серверов
* ОС персональных компьютеров
* ОС встраиваемых систем
* ОС реального времени

Тенденции:

* Поддержка большего числа архитектур CPU.
* Поддержка большего количества периферийных устройств.
* Оптимизация кода: внедрение большого числа микро- и архитектурно-зависимых оптимизаций.
* Сохранение обратной совместимости с пользовательским ПО (сохранение бинарного интерфейса системных вызовов).
* Hardening (усиление безопасности, фикс уязвимостей, внедрение новых мер безопасности).
* Сетевые возможности: поддержка многих сетевых карт, реализация известных сетевых протоколов канального, сетевого, транспортного уровней, добавление
  новых возможностей по конфигурированию сети (пример, nl80211 -- конфигурирование Wi-Fi, netlink -- замена интерфейса ioctl'ов для сетевых модулей).
* Поддержка аппаратной виртуализации (KVM -- поддержка Intel VT-x).

################################################################################

50. Управление процессами и потоками: представление процессов и потоков в операционных системах, дисциплины планирования процессов, взаимодействие процессов, проблема тупиков.

__Процесс__ - абстракция, описывающая исполняемую на компьютере программу. Процесс является единицей управления ресурсами: иными словами, ОС планирует ресурсы ЭВМ на уровне процессов
(за исключением, CPU). Каждый процесс характеризуется своей собственной виртуальной памятью, а также своими ресурсами ввода/вывода (открытые файлы, используемые сокеты).
__Поток__ - исполняемая единица. Любой поток принадлежит некоторому процессу, исполняется в его контексте. При этом каждый процесс может иметь несколько потоков -- таким образом
реализуется многопоточность приложений. ОС распределяет ресурсы CPU на уровне потоков. Каждый поток при этом характеризуется своим собственным контекстом исполнения (регистры,
стек).

__Планирование__ - определение следующего выполняющегося потока (а следовательно, процесса) на CPU.

Алгоритмы (дисциплины) планирования.

Планирование в пакетных (=неинтерактивных) системах
1) FIFO. Запускаемые процессы помещаются в очередь (FIFO). Следующим исполняемым процессом на CPU выбирается тот, кто располагается самым первым в очереди.
При использоваии данного алгоритма центральный процессор выделяется процессам в порядке поступления их запросов. При этом процесс исполняется на CPU до тех пор, пока не
будет заблокирован по причине выполнения операции ввода/вывода или пока не завершится.
2) Самое короткое задание первым. Следующим исполняемым на cpu заданием будет процесс, требующий самое короткое время для своего завершения. Эффективен, если задания доступны планировщику
одновременно. В случае последовательного поступления заданий превращается в алгоритм FIFO.
3) Приоритет наименьшему времени выполнения. Следующим исполняемым на cpu заданием будет процесс, оставшееся время исполнения которого минимально.

Планирование в интерактивных системах:
4) Циклическое планирование. Каждому процессу выделяется квант времени, в течение которого он может исполняться. По истечении этого кванта времени, процесс прерывается, и ресурсы CPU
переходят другому процессу. В случае если процесс перешел в заблокированное состояние по вводу/выводу или завершился, то планирование осуществляется именно в этот момент. По исчерпании кванта времени,
прерванный процесс помещается в конец FIFO. Следующим исполняемым процессом выбирается тот, кто находится в начале FIFO.
5) Приоритетное планирование. Аналогичен алгоритму циклического планирование, за исключением того, что каждому процессу присваивается приоритет. Следующим исполняемым на CPU процессом выбирается тот,
который находится в состоянии готовности (не заблокирован вводом/выводом) и имеет наивысший приоритет. В качестве реализации может быть использовано несколько очередей (FIFO).
Процессы разного приоритета помещаются в разные очереди.
6) Гарантированное планирование. Учитываются 3 характеристики:
t - время, в течение которого процесс исполнялся на CPU,
T - время, прошедшее с момента запуска процесса,
n - количество исполняющихся процессов.
ОС исходит из идеи, что каждый процесс имеет право на время CPU в размере t' = T/n (каждому процессу выделяется одинаковое количество процессорного времени).
Для каждого процесса подсчитываются величины d = t/t' = (t * n) / T. Следующим исполняемым процессом выбирается тот, у которого величина d наименьшая:
такой процесс "недополучил" больше процессорного времени, чем его конкуренты.
7) Лотерейное планирование. Следующий процесс выбирается при помощи датчика случайных чисел. Возможна настройка вероятности "быть выбранным", путём задания численных приоритетов и их учёта.

Взаимодействие процессов.

Одним из свойством процесса является его "изолированность" от других процессов: таким образом достигается иллюзия единоличного владения ресурсами компьютера.
Тем не менее, возникает необходимость обмена данными между различными процессами.
Существуют следующие механизмы межпроцессорного взаимодействия (на примере ОС Linux):

1) Использование разделяемых областей памяти. Нескольким процессам отображается в виртуальное адресное пространство одна и та же физическая страница оперативной памяти.
За счёт этого появляется возможность взаимодействия процессов через выделенную область памяти.
Использование разделяемой памяти доступно в ОС Linux через системный вызов mmap с флагом MAP_SHARED.
2) Сигналы. Сигналы UNIX (signals) являются ограниченным, но полезным способом межпроцессорной коммуникации. По сути, сигнал - это аналог прерывания для CPU.
При поступлении сигнала вызывается специальный обработчик процесса, который выполняет некоторые действия. Одни сигналы имеют чёткую семантику (как например, SIGALRM - сигнал от таймера),
семантика других же определяется самим процессом (как например, SIGUSR1, SIGUSR2).
3) UNIX-сокеты. Механизм работы данного способа межпроцессорного взаимодействия аналогичен обычным TCP/UDP сокетам. Один процесс (сервер) прослушивает определённый сокет,
идентифицируемый путём в VirtualFS (VFS). Другой процесс (клиент) "подключается" к этому сокету и посылает через него сообщения определённого формата.
Процесс-сервер получает данное сообщение и выполняет соответствующие действия. Подобный способ межпроцессорного взаимодействия использует большинство демонов (daemons) ОС.
4) Канал (pipe). Канал - механизм межпроцессорного взаимодействия между процессом-родителем и дочерним процессом. Процесс-родитель записывает данные в один из концов канала, идентифицируемый
файловым дескриптором на запись (fd). Дочерний процесс же считывает эти данные с другого конца (файловый дескриптор на чтение). Обычно создаваемые файловые дескрипторы заменяют stdin или stdout процесса,
поэтому межпроцессорное взаимодействие эффективно выглядит как получение пользовательского ввода/вывода.
5) Коммуникация через файлы. Обычные файлы VFS тоже могут являться способом взаимодействия процессов. При этом коммуницировать можно как через содержимое файла, так и через сам факт наличия файла.
Последнее используется в так называемых lock или pid файлах, которые свидетельствуют о наличии определённого процесса или о выполнении определённого действия в системе.
6) Сетевые сокеты TCP/UDP как способ взаимодействия удалённых процессов (исполняющихся на различных машинах).

Проблема тупиков.

При использовании разделяемых областей памяти (или вообще любых разделяемых ресурсов, к примеру, принтера) появляется необходимость синхронизации процессов:
иными словами, требуется некоторая сериализация выполняемых над разделяемых ресурсом операций так, чтобы исключить одновременное его использование.
Участок кода программы, работающий с разделяемым ресурсом (например, памятью), называется __критической секцией__.

Для безопасного использования разделяемого ресурса используются дополнительные переменные, семантика которых аналогична "светофору":
одно значение переменной, к примеру 0, говорит о том, что ресурс в настоящие момент не используется;
другое значение, к примеру любое ненулевое значение, говорит о том, что ресурс в настоящее время занят.

Необходимым условием возможности использования переменных для синхронизации является аппаратная поддержка атомарной операции __"test-and-set"__.
Данная операция выполняется по следующему алгоритму _атомарно_:
1) В переменную записывается ненулевое значение (например, 1).
2) Предыдущее значение переменной сохраняется в специальном регистре.
Программное обеспечение при этом имеет возможность узнать, успешно ли была взята блокировка, по значению, сохранённому в регистре.

Для сериализации исполняемых операций используются следующие примитивы синхронизации:
1) Cпинлок (spinlock) -- процесс пытается циклически выполнить операцию "test-and-set" до тех пор, пока не преуспеет.
2) Мьютекс (mutex) -- процесс прерывается операционной системой в случае неудачного выполнения операции "test-and-set".
В случае успеха процесс продолжает свою работу.
3) Семафор (semaphore) -- счётчик. Для его реализации часто задействуется атомарная операция compare-and-add,
помещающее в переменную не новое ненулевое значение, а сумму предыдущего и указанного в коде операции.
По сути подсчитывает оставшееся число разделяемого ресурса. В случае его отсутствия (счётчик = 0) процесс также прерывается.
Мьютекс иначе называется бинарным семафором.

__Проблема тупиков__ возникает при наличии нескольких процессов и нескольких разделяемых ресурсов.
Пример тупика:

                    Ресурсы
Процессы         1          2
                 ^          ^
                 |          |
   A     --------/          |
                            |
   B     -------------------/

Стрелочками нарисованы взятые разделяемые ресурсы 1, 2 каждым из процессов A и B.
После этого, если процесс A попытается взять ресурс 2, а процесс B - ресурс 1, возникнет ситуация тупика (__deadlock__).

Условия возникновения тупиков:
1) Условие взаимного исключения. Каждый ресурс либо выделен в данный момент только одному процессу, либо доступен.
2) Условие удержания и ожидания. Процессы, удерживающие в данный момент ранее выделенные им ресурсы, могут запрашивать новые ресурсы.
3) Условие невыгружаемости. Ранее выделенные ресурсы не могут быть принудительно отобраны у процесса. Они должны быть явным образом
высвобождены тем процессом, который их удерживает.
4) Условие циклического ожидания. Должна существовать кольцевая последовательность из двух и более процессов, каждый из которых ожидает высвобождения ресурса,
удерживаемого следующим членом последовательности.

Для возникновения тупика должны соблюдаться все четыре условия.

################################################################################

51. Управление оперативной памятью: управление физической и виртуальной памятью, реализация свопинга.

Современные CPU имеют одним из компонент диспетчер памяти (MMU, Memory Management Unit).
Задача MMU -- преобразовывать поступающие на входе виртуальные адреса в физические,
реально выставляемые на адресных линиях системной шины.
Данный аппаратный компонент является основой построения виртуальной памяти.
Программное управление диспетчером памяти осуществляется через специальные регистры CPU,
а также через структуры данных, находящиеся в оперативной памяти (такие структуры данных описывают правила
преобразования виртуального адреса в физический).

Виртуальная память:

Виртуальное адресное пространство состоит из блоков фиксированного размера (обычно 4 Кб), называемых страницами.
Соответствующие блоки в физической памяти называются страничными блоками. Страницы и страничные блоки имеют,
как правило, одинаковые размеры. Перенос информации между оперативной памятью и диском (при свопинге) всегда осуществляется целыми страницами.

Пример организации виртуальной памяти (надо просто понять суть по диаграмме, учить дословно необязательно :)):

             ВИРТУАЛЬНАЯ ПАМЯТЬ
                     --------
               60-64K|  x   |
                     --------
               56-60K|  x   |
                     --------
               52-56K|  x   |
                     --------
               49-52K|  x   |
                     --------
               44-48K|  7   |-----------\
                     --------            \
               40-44K|  x   |             \
                     --------              \
               36-40K|  5   |----\          \
                     --------     \          \
               32-36K|  x   |      \          \     ФИЗИЧЕСКАЯ ПАМЯТЬ    PFN (Page Frame Number)
                     --------       \          \        --------
               28-32K|  x   |        \          \------>|      |28-32K             7
                     --------         \                 --------
               24-28K|  x   |          \  /------------>|      |24-28K             6
                     --------           \/              --------
               20-24K|  3   |------\    /\------------->|      |20-24K             5
                     --------       \  /                --------
               16-20K|  4   |--------\/---------------->|      |16-20K             4
                     --------        /\                 --------
               12-16K|  0   |------\/  \--------------->|      |12-16K             3
                     --------      /\                   --------
                8-12K|  6   |-----/  \    /------------>|      |8-12K              2
                     --------         \  /              --------
                 4-8K|  1   |----------\/-------------->|      |4-8K               1
                     --------          /\               --------
                 0-4K|  2   |---------/  \------------->|      |0-4K               0
                     --------                           --------

На диаграмме выше приняты следующие обозначения: диапазон, помеченный 0-4K означает, что виртуальные
или физические адреса этой страницы составляют от 0 до 4095. Диапазон 4-8K ссылается на адреса от
4096 до 8191 включительно и так далее. Каждая страница содержит строго 4096 адресов, которые начинаются с чисел,
кратных 4096, и заканчиваются числама на единицу меньше чисел, кратных 4096.
К примеру, когда программа обращается к памяти по адресу 0, диспетчеру памяти поступает на вход виртуальный адрес 0.
Диспетчер памяти вычисляет, что адрес относится к нулевой виртуальной странице. Данной странице соответствует физический блок с PFN=2.
Соответственно, на адресные линии выставляет значение 8192. Оперативная память не знает о существовании диспетчера и видит только запрос на чтение/запись
по адресу 8192, который и выполняет. Таким образом, диспетчер памяти эффективно справляется с отображением всех виртуальных адресов в диапазоне [0, 4095] на
физические адреса [8192, 12 287]. По аналогии происходят трансляции и в других виртуальных страницах.

Важно отметить, что во всех случаях отображение имеет характер один-к-одному (биекция).

Сама по себе возможность отображения 16 виртуальных страниц на 8 страничных блоков за счёт соответствующей настройки таблиц диспетчера
не решает проблемы превышения объема виртуальной памяти над объемом физической памяти. Поскольку в нашем распоряжении только 8 физических страничных блоков, то на
физическую память могут отображаться только 8 виртуальных страниц. Остальные страницы, помеченные на рисунке крестиками, в число отображаемых не попадают.
Реальное оборудование отслеживает присутствие конкретных страниц в физической памяти за счёт __бита присутствия-отсутствия__.

В случае если программа обращается к странице, на данный момент не отображенной в оперативную память, диспетчер памяти генерирует исключение "отсутствие страницы"
(page fault). Операционная система выбирает редко используемый страничный блок и сбрасывает его содержимое на диск. Затем она извлекает с диска запрошенную страницу,
помещает её в только что освободившийся страничный блок, вносит изменения в таблицы трансляций и заново запускает прерванную инструкцию.

Алгоритмы замещения страниц.

В случае возникновения `page fault`-исключения, ядро операционной системы должно выбрать страницу, которую требуется поместить на диск.
Есть различные подходы к тому, какую именно страницу необходимо выбрать:

1) NRU (Not Recently Used, исключение давно не использовавшейся страницы). Данный алгоритм реализуется на основе двух битов дескрипторов страниц, управляемых как аппаратно, так и программно:
   * R - устанавливается при каждом обращении к странице;
   * M - устанавливается при изменении страницы.
При запуске процесса оба страничных бита по умолчанию равны 0.
Периодически (например, по прерыванию от таймера) бит R сбрасывается, чтобы отличить те страницы,
к которым в последнее время были обращения от тех, к которым обращений не было.
При возникновении ошибки отсутствия страницы ядро операционной системы просматривает все страницы и на основе текущих значений
битов M, R делит их на четыре класса:
   * Класс 0: в последнее время не было ни обращений, ни модификаций.
   * Класс 1: обращений в последне время не было, но страница модифицирована.
   * Класс 2: в последнее время были обращения, но модификаций не было.
   * Класс 3: были и обращения, и модификации в последнее время.
Страницы класса 1 появляются в том случае, если у страниц класса 3 бит R сбрасывается по прерыванию от таймера.
Эти прерывания не сбрасывают бит M, поскольку содержащаяся в нём информация необходима для того, чтобы узнать,
нужно ли перезаписывать страницу на диске. Сброс бита R без бита M приводит к возникновению страниц класса 1.
Алгоритм NRU удаляет произвольную страницу, относящуюся к самому низкому непустому классу.
В основе алгоритма заложена идея, что лучше удалить модифицированную страницу, к которой не было обращений по крайней мере
за последний такт системных часов, чем удалить интенсивно используемую страницу.
Алгоритм NRU позволяет достичь приемлемой производительности.
2) FIFO. Операционная система ведёт список всех физических страниц. Недавно загруженные с диска страницы поступают в конец списка.
При возникновении исключения отсутствия страницы удаляется страница, находящаяся в голове списка.
3) Алгоритм "Второй Шанс". Модификация алгоритма FIFO, учитывающая бит R. У страницы, находящейся в голове списка, проверяется бит R.
Если он равен 1, то бит сбрасывается, а сама страница помещается в конец списка, но не удаляется. Если он равен 0, то действия аналогичны алгоритму FIFO.
Если страница не удалена, то проверяется следующая по очередности страница. С ней происходят те же самые проверки и операции.
Вырожденный случай -- все страницы были использованы. В таком случае по алгоритму у каждой страницы будет сброшен бит R, а суммарный эффект будет аналогичен алгоритму FIFO.
Эффективная реализация данного алгоритма -- манипулирования одними указателями без физического перемещения дескрипторов страниц.
4) LRU (Least Recently Used, исключение наименее востребованной страницы). Для каждой страницы ведётся специальнй счётчик.
При возникновении прерывания от таймера операционная система сканирует все страницы и добавляет к счётчику каждой страницы текущее значение R.
После этого значение R также сбрасывается. При возникновении ошибки отсутствия страницы, удаляется страница, имеющая наиманьшее значение счётчика.
5) "Рабочий набор".
Данный метод основывается на том наблюдении, что большинство программ обращается к адресному пространству неравномерно.
Набор страниц, используемых процессом в настоящий момент, называется __рабочим_набором__.
На практике приближённо определить рабочий набор можно по критерию: рабочий набор - страницы, к которым были обращения за последние N мс
(время виртуальное, равное интервалу времени, в течение которого задача исполняется на CPU).
При возникновении ошибки отсутствия страницы выбирается страница, не принадлежащая рабочему набору.

################################################################################

52. Управление устройствами ввода/вывода: система прерываний, системы драйверов внешних устройств.

CPU взаимодействует с периферийным оборудованием, выставляя на адресных линиях системной шины специальные адреса, воспринимаемые контроллером внешнего устройства.
Данный метод взаимодействия называется отображенным в память вводом/выводом (MMIO, Memory Mapped Input/Output).
Таким образом, используя привычные инструкции пересылки из памяти/в памяти MOV, LW/SW, можно считывать различные данные от устройства,
включая его состояние.

Методы ввода/вывода:
1) Активное ожидание/Опрос. Перед каждой пересылкой данных к контроллеру внешнего устройство операционная система считывает со специального регистра устройства
его состояние, которое можно охарактеризовать как готово/не готово.

На псевдокоде данный метод можно описать как:

volatile u32 *data_register   = (volatile u32 *) <Адрес регистра, куда записываются данные>;
volatile u32 *status_register = (volatile u32 *) <Адрес регистра, откуда можно считать состояние устройства>;
while (*status_register != READY);
*data_register = <Записываемые данные>;

2) Ввод/вывод, управляемый прерываниями. Вместо того чтобы ожидать устройство на готовность, контроллер данного устройства программируется
операционной системой таким образом, чтобы инициировать прерывание CPU по завершении операции -- готовности устройства. Таким образом, циклы CPU
не расходуются впустую. При наступлении прерывания CPU останавливает выполнение текущей задачи и переходит к выполнению специальной процедуры,
называемой обработчиком прерывания.

На псевдокоде данный метод можно описать как:

Начальный запрос устройства:

volatile u32 *data_register   = (volatile u32 *) <Адрес регистра, куда записываются данные>;
volatile u32 *status_register = (volatile u32 *) <Адрес регистра, откуда можно считать состояние устройства>;
volatile u32 *interrupt_register = (volatile u32 *) <Адрес регистра, управляемого генерацией устройством прерываний CPU>;
*interrupt_register = ENABLE_INTERRUPTS;    /* Включаем прерывания на контроллере внешнего устройства */
enable_cpu_interrupts();                    /* Включаем прерывания на CPU */
while (*status_register != READY);
*data_register = <Записываемые данные>;

Обработчик прерывания:

volatile u32 *data_register   = (volatile u32 *) <Адрес регистра, куда записываются данные>;
acknowledge_interrupt();                    /* Посылка контроллеру прерывания информации о завершении обработки прерывания */
return_from_interrupt();

3) Ввод/вывод с использованием DMA.

CPU конфигурирует контроллер DMA, либо принадлежащий самому устройству, либо выступающий в качестве самостоятельного устройства, таким образом, чтобы:
 * был осуществлен трансфер заданного буфера оперативной памяти в устройство;
 * по окончании трансфера было инициировано прерывание CPU.

На псевдокоде данный метод выглядит следующим образом:

Начальный запрос устройства:

set_up_DMA_controller();

Обработчик прерывания:

acknowledge_interrupt();
return_from_interrupt();

Драйвера внешних устройств.

__Драйвер__ - программа, управляющая работой внешнего устройство через взаимодействие с его контроллером.
В своей работе драйвер использует описанные выше методы ввода/вывода, а также MMIO.

Драйвера входят в состав ядра операционной системы и имеют с ним чётко обозначенный интерфейс, зависящий от
подсистемы ядра, в которую входит драйвер (сетевая подсистема, подсистема PCI и т. п.).

Любой драйвер имеет в своем составе функцию инициализации, в которой:
 * происходит проверка присутствия нижележающего оборудования с помощью запросов через MMIO;
 * происходит идентификация оборудования (через чтение специализированных регистров устройства);
 * в случае если оборудование присутствует и поддерживается драйвером, происходит обращение к ядру операционной системы
 для установки обработчика прерывания от устройства.
 * драйвер регистрирует себя в подсистеме ядра; таким образом, он становится доступен пользовательскому пространству.

################################################################################

53. Управление файловыми системами: организация дискового пространства, современные файловые системы.

__Файловая_система__ - способ хранения файлов на долговременном носителе.
__Файл__ - именованная последовательность байт, хранящаяся на долговременном носителе.

Организация дискового пространства.

Цель организации дискового пространства - эффективное отслеживание соответствие файлов блоков на диске.

Расположение файлов:

1) Непрерывное размещение. Файлы располагаются на долговременном носителе информации
в виде непрерывной последовательности блоков.
Таким образом, при размере блока 512 байт, файл размером 10 Кб займет на диске 20 последовательных блоков.


      Файл A (4 блока)   Файл B (3 блока)           Файл C (6 блоков)
            |                    |                         |
            |                    |                         |
 ----  ----  ----  ----  ----  ----  ----  ----  ----  ----  ----  ----  ---- 
|++++||++++||++++||++++||@@@@||@@@@||@@@@||++++||++++||++++||++++||++++||++++| ...
|++++||++++||++++||++++||@@@@||@@@@||@@@@||++++||++++||++++||++++||++++||++++| ...
 ----  ----  ----  ----  ----  ----  --- - ----  ----  ----  ----  ----  ---- 

Пример организации хранилища показан на диаграмме выше. Здесь следует заметить, что каждый следующий файл записывается сразу после предыдущего.
Следует заметить также, что каждый новый файл начинается от границы нового блока. Поэтому, если фактически файл A занимает 3,5 блоков, то
пространство будет потеряно впустую (фрагментация).

При удалении блоки, занимаемые файлов, помечаются как свободные. Перемещение файлов не производится, поскольку может занимать значительное время.
Фрагментация неизбежна.

2) Размещение с использованием связанного списка. Представление каждого файла в виде связанного списка дисковых блоков.
При этом первое слово каждого блока используется в качестве указателя на следующий дисковый блок, а вся остальная часть блока предназначена для хранения данных.


                                     ФАЙЛ A.

         --------      --------      --------      --------      --------
        |        |--->|        |--->|        |--->|        |--->|  NULL  |    
        |        |    |        |    |        |    |        |    |        |    
         --------      --------      --------      --------      --------     
        |        |    |        |    |        |    |        |    |        |    
        | Блок 0 |    | Блок 1 |    | Блок 2 |    | Блок 3 |    | Блок 4 |    
        |        |    |        |    |        |    |        |    |        |    
        | файла  |    | файла  |    | файла  |    | файла  |    | файла  |    
        |        |    |        |    |        |    |        |    |        |    
        |        |    |        |    |        |    |        |    |        |    
         --------      --------      --------      --------      --------     

Физический  4             7              2            10            12
  блок


                                     ФАЙЛ B.

         --------      --------      --------      -------- 
        |        |--->|        |--->|        |--->|  NULL  |
        |        |    |        |    |        |    |        |
         --------      --------      --------      -------- 
        |        |    |        |    |        |    |        |
        | Блок 0 |    | Блок 1 |    | Блок 2 |    | Блок 3 |
        |        |    |        |    |        |    |        |
        | файла  |    | файла  |    | файла  |    | файла  |
        |        |    |        |    |        |    |        |
        |        |    |        |    |        |    |        |
         --------      --------      --------      -------- 

Физический  6             3             11            14
  блок

В отличие от непрерывного хранения файлов, в этом методе может быть использован каждый дисковый блок.
При этом потери дискового пространства на фрагментацию отсутствуют (за исключением внутренней фрагментации в последнем блоке).
Кроме того, достаточно, чтобы в записи каталога хранился только дисковый адрес первого блока. Всю остальную информацию
можно найти начиная с этого блока. В то же время доступ к файлам, хранящимся подобным образом осуществляется медленее,
чем к последовательно хранимым файлам.

3) Размещение с использованием связанного списка, использующего таблицу в памяти (FAT, File Allocation Table).
Развитие второго метода, при котором указатели хранятся на долговременном носителе информации в виде массива,
где индекс элемента равен номеру физического блока.
При инициализации файловой системы данная таблица загружается в оперативную память, за счёт
чего можно быстро вычислить требуемый физический блок.

  Физический
     блок
          ----------
        0 |        |
          ----------
          ----------
        1 |        |
          ----------
          ----------
        2 |   10   |
          ----------
          ----------
        3 |   11   |
          ----------
          ----------
        4 |    7   |  <---- ФАЙЛ A НАЧИНАЕТСЯ ЗДЕСЬ.
          ----------
          ----------
        5 |        |
          ----------
          ----------
        6 |    3   |  <---- ФАЙЛ B НАЧИНАЕТСЯ ЗДЕСЬ.
          ----------
          ----------
        7 |    2   |
          ----------
          ----------
        8 |        |
          ----------
          ----------
        9 |        |
          ----------
          ----------
       10 |   12   |
          ----------
          ----------
       11 |   14   |
          ----------
          ----------
       12 |   -1   |
          ----------
          ----------
       13 |        |
          ----------
          ----------
       14 |   -1   |
          ----------
          ----------
       15 |        |  <---- НЕИСПОЛЬЗУЕМЫЙ БЛОК.
          ----------

Существенным недостатком данного метода является прямая пропорциональность
дополнительно требуемой памяти объему памяти долговременного носителя информации.
При больших объемах памяти долговременного носителя информации данный
метод неприменим.

3) I-узлы (inodes). С каждым файлов связывается i-узел. При этом i-узлы всех файлов
не обязательно должны хранится в оперативной памяти одновременно.
I-узел (inode) - специальная структура данных, содержащая атрибуты файлов, а также дисковые адреса его блоков.
Схема i-узла:

          ----------------------------
          |                          |
          |      Атрибуты файла      |
          |                          |
          ----------------------------
          ----------------------------
          |      Адрес блока 0       | ------>
          ----------------------------
          ----------------------------
          |      Адрес блока 1       | ------>
          ----------------------------
          ----------------------------
          |      Адрес блока 2       | ------>
          ----------------------------
          ----------------------------
          |      Адрес блока 3       | ------>
          ----------------------------
          ----------------------------
          |      Адрес блока 4       | ------>
          ----------------------------
          ----------------------------
          |      Адрес блока 5       | ------>
          ----------------------------
          ----------------------------
          |      Адрес блока 6       | ------>
          ----------------------------
          ----------------------------
          |      Адрес блока 7       | ------>
          ----------------------------
          ----------------------------         ----------------
          |  Адрес блока указателей  | ------> |              |
          ----------------------------         |  Блок диска  |
                                               |  содержащий  |
                                               |дополнительные|
                                               |   дисковые   |
                                               |    адреса    |
                                               |              |
                                               ----------------

Многие файловые системы UNIX, а также NTFS используют именно
этот способ хранения информации на долговременном носителе.

################################################################################

54. Сетевые возможности современных операционных систем:
архитектура сетевых операционных систем, реализация операционных систем для различных типов компьютерных сетей, сетевые службы.

__Сетевая_операционная_система__ - операционная система, поддерживающая работу по компьютерной сети.
Примеры сетевых ОС: Linux, Windows.

Архитектура сетевой операционной системы.

0) На самом нижним уровне выступают драйвера сетевых карт.
Драйвера коммуницируют с сетевой картой посредством специальных структур данных - дескриптора.
Схема типового дескриптора изображена ниже:

        --------------------
        | Физический адрес |
        |   передаваемых   |
        |      данных      |
        --------------------
        --------------------
        |   Длина пакета   |
        |         +        |
        |       флаги      |
        --------------------
        --------------------
        | Физический адрес |
        |   следующего     |
        |   дескриптора    |
        --------------------
        |                  |
        |                  |
        ~   Выравнивание   ~
        ~  (игнорируется)  ~
        |                  |
        |                  |
        --------------------

Каждый дескриптор содержит указатель на следующий.
Совокупность дескрипторов образует кольцевой односвязный список.
Именно через дескрипторы происходит приём/отправка пакетов по физическому носителю (витая пара, радиоэфир и т.п.)

1) Обработка данных на канальном уровне. Реализуется совместными усилиями драйвером сетевого устройства и
интерфейса ядра между сетевым стеком и драйвером сетевого устройства. На данном уровне проверяется, что
mac-адрес узла-получателя совпадает с mac-адресом сетевой платы, на которую пришел пакет.
Также определяется протокол верхнего уровня (сетевого): arp, ipv4, ipv6 и т. п.
Организуется передача полученного пакета модулю ядра, реализующего протокол сетевого уровня.
При отправке происходит заполнение заголовка канального уровня и передача его драйверу сетевого устройства.

2) Обработка данных на сетевом уровне. Реализуется модулем ядра - реализацией сетевого протокола.
На данном уровне происходит анализ сетевого адреса назначения, а также определения дальнейшего пути пакета:
 * input -- пакет предназначен для текущего хоста на сетевом уровне.
 * output -- пакет сгенерирован текущим хостом и должен быть передан драйверу сетевого устройства.
 * forward -- пакет предназначен другому хосту, путь до которого содержится в таблицах маршрутизации текущего хоста.
В соответствии с определённым назначением, пакет либо передается протоколу верхнего уровня (tcp/udp, icmp),
либо передается драйверу сетевого устройства для отправки (output, forward).

3) Обработка данных на транспортном уровне. Реализуется модулем ядра - реализацией транспортного протокола.
На данном уровне происходит контроль целостности передаваемых/получаемых данных (за счёт подтверждения полученных пакетов - для tcp),
ликвидация дубликатов,
а также контроль порядка (за счёт нумерации отправляемых пакетов в заголовке транспортного уровня - tcp).
При получении пакета ищется задача, его ожидающая (задача, которой принадлежит сокет).
Если задача найдена, то происходит переключение задачи в состояние готовности, а также передача ей полученных данных.

4) Интерфейс сокетов. Является интерфейсом пользовательского пространства
к сетевым возможностям операционной системы. Реализуется через механизм системных вызовов.

Интерфейс традиционно включает в себя следующие примитивы:

  * socket -- создает в пространстве ядра сокет, принадлежащий определённому протоколу
  (address family), возвращает целое число, идентифицирующее созданный сокет
  (в Linux - файловый дескриптор);
  * bind -- связывает сокет с сетевым адресом; адрес может включать в себя как
  сетевой адрес (IP-адрес), так и транспортный адрес (номер TCP/UDP порта);
  * listen -- для протоколов, ориентированных на соединение (TCP), разрешает приём
  входящих соединений к данному сокету;
  * accept -- ожидает подключения (tcp), после чего возвращает файловый дескриптор, с помощью
  которого можно взаимодействовать с подключившейся стороной;
  * connect -- инициирует соединение к хосту с заданным адресом (для tcp);
  * send -- отправляет данные по сети;
  * recv -- получает данные по сети;
  * close -- закрывает сокет, разрывая установленные соединения и завершая текущие операции.

Сетевые службы.

Программы пользовательского окружения, использующие сетевые возможности операционной системы
(интерфейс сокетов), называются сетевыми службами. Примеры сетевых служб:
  * DHCP клиент;
  * WEB-сервер;
  * Браузер;
  * NTPD -- демон, реализующий протокол ntp (синхронизация часов).

################################################################################

55.	БД и СУБД. Основные функции СУБД. Многоуровневая архитектура современных СУБД.
База Данных - организованная совокупность взаимосвязанных данных, предназначенных для многократного использования приложениями/пользователями.
Система Управления Базами Данных - совокупность программного обеспечения, необходимого для ведения, использования и поддержания баз данных в актуальном состоянии.

@Основные функции СУБД:
1)	Администрирование баз данных
	СУБД имеют развитые средства администрирования базы данных, например, для определения доступа к базе, ее архивации и защите хранимой информации. В связи с тем, что базы данных проникают сегодня во многие сферы деятельности человека, появилась новая профессия – администратор базы данных, человек, отвечающий за проектирование, создание, использование и сопровождение базы данных. В процессе эксплуатации БД администратор обычно следит за ее функционированием, обеспечивает защиту от несанкционированного доступа к хранимым данным, вносит изменения в структуру базы, контролирует достоверность информации в ней.
2)	Непосредственное управление данными во внешней памяти
	Эта функция предоставляет пользователю возможность выполнения основных операций с данными – хранение, извлечение и обновление информации. Она включает в себя обеспечение необходимых структур внешней памяти как для хранения данных, непосредственно входящих в БД, так и для служебных целей, например, для ускорения доступа к данным. СУБД поддерживает собственную систему именования объектов БД.
3)	Управление буферами оперативной памяти
	СУБД обычно работают с БД значительного размера; очень часто этот размер существенно больше доступного объема оперативной памяти. Так как при обращении к любому элементу данных будет производиться обмен с внешней памятью, то вся система будет работать со скоростью устройства внешней памяти. Практически единственным способом реального увеличения этой скорости является буферизация данных в оперативной памяти. Однако этого недостаточно для целей СУБД, поэтому в развитых СУБД поддерживается собственный набор буферов оперативной памяти.
4)	Управление транзакциями
	Транзакция – это последовательность операций над БД, которые рассматриваются СУБД как единое целое и позволяют добавлять, удалять или обновлять сведения о некотором объекте в базе (по существу это некоторый программный код, написанный на одном из языков управления данными). Либо транзакция успешно выполняется, и СУБД фиксирует изменения БД, произведенные этой транзакцией, либо ни одно из этих изменений никак не отражается на состоянии БД. Например, если в результате транзакции произошел сбой компьютера, база данных попадает в противоречивое положение – некоторые изменения уже внесены, остальные нет. Транзакция позволяет вернуть базу в первоначальное непротиворечивое состояние (отменить все выполненные изменения).
	Свойства транзакций:
	-	свойство атомарности (Atomicity) выражается в том, что транзакция должна быть выполнена в целом или не выполнена вовсе;
	-	свойство согласованности (Consistency) гарантирует, что по мере выполнения транзакций данные переходят из одного согласованного состояния в другое — транзакция не разрушает взаимной согласованности данных;
	-	свойство изолированности (Isolation) означает, что конкурирующие за доступ к базе данных транзакции физически обрабатываются последовательно, изолированно друг от друга, но для пользователей это выглядит так, как будто они выполняются параллельно;
	-	свойство долговечности (Durability) трактуется следующим образом: если транзакция завершена успешно, то те изменения в данных, которые были ею произведены, не могут быть потеряны ни при каких обстоятельствах (даже в случае последующих ошибок).
5)	Журнализация
	Одним из основных требований к СУБД является надежность хранения данных во внешней памяти. Под надежностью хранения понимается то, что СУБД должна быть в состоянии восстановить последнее состояние БД после любого аппаратного или программного сбоя (аварийное выключение питания, аварийное завершение работы СУБД или аварийное завершение пользовательской программы).
	Наиболее распространенным методом поддержания надежности хранения является ведение журнала изменений БД. Журнал – это особая часть БД, недоступная пользователям и поддерживаемая с особой тщательностью (иногда поддерживаются две копии журнала, располагаемые на разных физических дисках), в которую поступают записи обо всех изменениях основной части БД. Изменения БД журнализуются следующим образом: запись в журнале соответствует некоторой операции изменения БД (например, операции удаления строки из таблицы реляционной БД). С помощью журнала можно решить все проблемы восстановления БД после любого сбоя.
6)	Поддержка языков БД
	СУБД включает язык определения данных, с помощью которого можно определить структуру базы, тип данных в ней, указать ограничения целостности (это язык, с помощью которого задаются различные имена, свойства объектов). Кроме того, СУБД позволяет вставлять, удалять, обновлять и извлекать информацию из базы данных посредством языка управления данными – языка запросов, который позволяет выполнять различные действия с данными, осуществлять их поиск и выборку. Он содержит набор различных операторов (заносить данные, удалять, модифицировать, выбирать и т.д.). Процесс извлечения данных и их обработка скрыты от пользователя. Стандартным языком наиболее распространенных в настоящее время СУБД является язык SQL (Structured Query Language). Он имеет сразу два компонента: язык определения данных и язык управления данными.

@Многоуровневая архитектура современных СУБД:
СУБД имеет многоуровневую структуру, в которой реализуется принцип относительной независимости логической и физической организации данных.

 -----             ------------------             ------------------------------------
|     |           |                  |           |    -----      -----                |
| КТ1 |---------->|                  |           |   | ВМ1 |    | ВМn |               |
|     |           |                  |           |    -----      -----                |     ################
 -----            |                  |           |       ^    -----^                  |     #              #
                  |                  |           |       |   |                        |     #              #
 -----            |                  |           |     ------               ------    |     #              #
|     |           |                  |           |    |      |             |      |   |     #              #
| КТ2 |---------->|        КМ        |-----------|--->|  ЛМ  |------------>|  ФМ  |---|---->#      БД      #
|     |           |                  |           |    |      |             |      |   |     #              #
 -----            |                  |           |     ------               ------    |     #              #
                  |                  |           |                                    |     #              #
 -----            |                  |           |                                    |     #              #
|     |           |                  |           |                                    |     ################
| КТ3 |---------->|                  |           |                                    |
|     |           |                  |           |               СУБД                 |
 -----             ------------------             ------------------------------------


КТi – это концептуальные требования на уровне понятий, их структур и взаимосвязей к данным, хранимым в БД, которые собираются и анализируются на начальном этапе проектирования БД;
КМ – концептуальная модель, которая представляет собой интегрированное представление КТi требований в терминах предметной области. В процессе построения КМ устраняются несоответствия, ошибки в КТi. КМ является средством аналогом базы знаний различных субъектов проекта об одной и той же предметной области. В значительной мере способствует успеху проектирования и сокращению сроков реализации проекта;
ЛМ – логическая модель, т.е. концептуальная модель предметной области, записанная в терминах конкретной области;
ФМ – физическая модель, т.е. описание способов хранения данных на физическом уровне, методов доступа к ним, способов индексации;
ВМi – внешние модели i-го пользователя/приложения, которые соответствуют его начальным КТi требованиям, но предоставляются в рамках конкретной СУБД;
Если на логическом уровне хранятся нормализованные данные, где информация об одном информационном объекте обычно хранится не в одной, а в нескольких взаимосвязных таблицах, то любая ВМi по сути является ненормализованным представлением, которое является не просто выпиской из ЛМ, а содержит нужные преобразования над данными (виртуальные атрибуты).
	
################################################################################

56.	Понятие модели данных (МД). Основные компоненты МД. Традиционные МД. Отличительные особенности семантических МД.
Модель данных - некоторая формальная теория представления и обработки данных, включающая методы описания типов и логических структур данных (аспект структуры), методы манипулирования данными (аспект манипуляции) и методы описания и поддержки целостности (аспект целостности).
Модель базы данных — тип модели данных, которая определяет логическую структуру базы данных и принципиально определяет, каким образом данные могут быть сохранены, организованы и обработаны.

@Основные компоненты модели данных:
1) Допустимая организация данных
2) Ограничения целостности
3) Множество допустимых операций

@Традиционные модели данных:
1) Иерархическая модель данных              -
2) Сетевая модель данных                     | https://ru.bmstu.wiki/Модели_баз_данных
3) Объекто-ориентированная модель данных    -
4) Реляционная модель данных

Концепции реляционной модели впервые были сформулированы в работах американского ученого Э. Ф. Кодда, откуда происходит ее второе название - модель Кодда. В реляционной модели объекты и взаимосвязи между ними представляются с помощью таблиц. В моделях реляционных баз данных широко используются три ключевых термина: отношения, атрибуты и домены. Отношение - это таблица со столбцами и строками. Именованные столбцы отношения называются атрибутами, а домен - это набор значений, которые могут принимать атрибуты. Строки таблицы со значениями разных атрибутов называют кортежами. Атрибут, значение которого однозначно идентифицирует кортежи, называется ключевым (или просто ключом). Так ключевое поле – это такое поле, значения которого в данной таблице не повторяется. Для отражения ассоциаций между кортежами разных отношений используется дублирование их ключей. Сложный ключ выбирается в тех случаях, когда ни одно поле таблицы однозначно не определяет запись. Записи в таблице хранятся упорядоченными по ключу. Ключ может быть простым, состоящим из одного поля, и сложным, состоящим из нескольких полей. Сложный ключ выбирается в тех случаях, когда ни одно поле таблицы однозначно не определяет запись. Кроме первичного ключа в таблице могут быть вторичные ключи, называемые еще внешними ключами, или индексами. Индекс – это поле или совокупность полей, чьи значения имеются в нескольких таблицах и которое является первичным ключом в одной из них. Значения индекса могут повторяться в некоторой таблице. Индекс обеспечивает логическую последовательность записей в таблице, а также прямой доступ к записи. 
Важным преимуществом реляционной модели является то, что в ее рамках действия над данными могут быть сведены к операциям реляционной алгебры, которые выполняются над отношениями. Это такие операции, как: объединение, пересечение, вычитание, декартово произведение, выборка, проекция, соединение, деление. Важнейшей проблемой, решаемой при проектировании баз данных, является создание такой их структуры, которая бы обеспечивала минимальное дублирование информации и упрощала процедуры обработки и обновления данных. Коддом был предложен некоторый набор формальных требований универсального характера к организации данных, которые позволяют эффективно решать перечисленные задачи. Эти требования к состоянию таблиц данных получили название нормальных форм. Первоначально были сформулированы три нормальные формы:
-	говорят, что отношение находится в первой нормальной форме, если все его атрибуты являются простыми;
-	говорят, что отношение находится во второй нормальной форме, если оно удовлетворяет требованиям первой нормальной формы и каждый не ключевой атрибут функционально полно зависит от ключа (однозначно определяется им);
-	говорят, что отношение находится в третьей нормальной форме, если оно удовлетворяет требованиям второй нормальной формы и при этом любой не ключевой атрибут зависит от ключа нетранзитивно. Транзитивной называется такая зависимость, при которой какой-либо не ключевой атрибут зависит от другого не ключевого атрибута, а тот, в свою очередь, уже зависит от ключа.
В дальнейшем появилась нормальная форма Бойса-Кодда и нормальные формы более высоких порядков. Однако они не получили широкого распространения на практике. Принципиальным моментом является то, что для приведения таблиц к состоянию, удовлетворяющему требованиям нормальных форм, или, как еще говорят, для нормализации данных над ними, должны быть осуществлены перечисленные выше операции реляционной алгебры. 
Основным достоинством реляционной модели является ее простота. Именно благодаря ей она положена в основу подавляющего большинства реально работающих СУБД. 
В разработанной Коддом реляционной модели были определены как требования к организации таблиц, содержащих данные, так и язык, позволяющий работать с ними. Впоследствии этот язык получил название SQL (Structured Query Language - структурированный язык запросов). Очень скоро SQL стал стандартом de facto языка работы с реляционными базами данных. В составе SQL могут быть выделены следующие группы инструкций:
-	язык описания данных (DDL, Data Definition Language): CREATE, DROP, ALTER;
-	язык манипулирования данными (DML, Data Manipulation Language): SELECT, INSERT, UPDATE, DELETE;
-	язык управления транзакциями: COMMIT, ROLLBACK, SAVEPOINT.

5) Нереляционная модель данных
Нереляционные СУБД – относительно недавнее пополнение множества систем для работы с данными. Их появление и растущая популярность вызваны, главным образом, развитием сетевых технологий и приложений. Современные сетевые приложения, наиболее яркими примерами которых являются социальные сети, должны поддерживать доступ одновременно для миллионов пользователей и хранить терабайты различных данных. К сожалению, при всех достоинствах, реляционные СУБД не могут обеспечить работу в таком режиме. Именно эта ситуация и вызвала значительный рост количества решений, позволяющих обеспечить эффективное хранение и обработку данных для высоконагруженных сетевых приложений.

@Отличительные особенности семантических моделей данных:
"Семантическое моделирование стало предметом интенсивных исследований с конца 1970-х годов. Основным побудительным мотивом подобных исследований (то есть проблемой, которую пытались разрешить исследователи) был следующий факт. Дело в том, что системы баз данных обычно обладают весьма ограниченными сведениями о смысле хранящихся в них данных. Чаще всего они позволяют лишь манипулировать данными определенных простых типов и определяют некоторые простейшие ограничения целостности, наложенные на эти данные. Любая более сложная интерпретация возлагается на пользователя. Однако было бы замечательно, если бы системы могли обладать немного более широким объемом сведений и несколько интеллектуальнее отвечать на запросы пользователя, а также поддерживать более сложные (то есть более высокоуровневые) интерфейсы пользователя..."
Семантическое моделирование представляет собой моделирование структуры данных, опираясь на смысл этих данных. В качестве инструмента семантического моделирования используются различные варианты диаграмм сущность-связь (ER - Entity-Relationship).
В рамках семантического моделирования используются четыре вида различных элементов: 
1) Сущности — некоторые различимые объекты, например, факультеты, кафедры, группы и студенты. Сущности бывают обычными и слабыми. Слабой является сущность, которая не может существовать, если не существует некоторая другая сущность. 
2) Свойства — некоторая информация, описывающая сущность, например, номер группы или фамилия студента. Свойства могут простыми или составными, однозначными или многозначными, базовыми или производными. Также обособлено выделяют ключевые и отсутствующие свойства. 
3) Связи — сущности, которые служат для обеспечения взаимодействия между двумя или несколькими другими сущностями. Количество сущностей, включенных в связь, определяет степень связи. При этом возможны следующие виды связей: «один к одному», «один ко многим» или «многие к одному», «многие ко многим». 
4) Подтипом одной сущности является другая сущность, каждый экземпляр которой является экземпляром первой сущности.

Особенности (из старого документа):
-	семантические модели отличаются большей выразительной мощностью, но, как правило, меньшим быстродействием. В частности, выразительная мощность отражается в гибкости структурных средств. Как правило семантические модели -  это графовые модели, позволяющие отразить сколь угодно сложные предметные области;
-	использование высокоуровневых абстракций. В семантических моделях, как правило, используются различного рода парадигматические отношения (класс - подкласс, часть - целое и т.д.);
-	как правило хранятся не только данные, но и знания, данные о данных(методанные), знания о знаниях(метознания);
-	богатый набор явных ограничений целостности;
-	существует возможность накладывать ограничения целостности не только на данные, но и на операции. И те и другие ограничения целостности накладываются в статике, а  контролируются в динамике. Ограничения целостности на данные накладываются на какой-то конкретный набор данных и контролируются после каждой операцией над этими данными. Ограничения целостности на операции накладываются на конкретные операции и  контролируются при проведении этих операций над любыми данными. Подобного рода подход позволяет расширять семантику стандартных операций.

################################################################################

57.	Администрирование современных СУБД. Обеспечения безопасности данных в современных СУБД на примере СУБД Oracle. Технологии удаленного доступа к системам баз данных, тиражирование и синхронизация в распределенных системах баз данных.

@Основные компоненты системы защиты баз данных:
1) Разграничение доступа - каждый пользователь, включая администратора, имеет доступ только к необходимой ему согласно занимаемой должности информации.
2) Защита доступа - доступ к данным может получить пользователь, прошедший процедуру идентификации и аутентификации. 
3) Шифрование данных - шифровать необходимо как передаваемые в сети данные для защиты от перехвата, так и данные, записываемые на носитель, для защиты от кражи носителя и несанкционированного просмотра/изменения не-средствами системы управления БД (СУБД). 
4) Аудит доступа к данным - действия с критичными данными должны протоколироваться. Доступ к протоколу не должны иметь пользователи, на которых он ведется.

@В подробностях:
1) Разграничение доступа
Для обеспечения разграничения доступа в версии СУБД 10g компания Oracle выпустила новый продукт Database Vault, предназначенный для предотвращения несанкционированного доступа к информации пользователей, в том числе наделенных особыми полномочиями, например, администраторов базы данных. Набор правил в Database Vault, разграничивающих доступ, достаточно широк. Например, руководство организации может определить правила, согласно которым для решения задач, предполагающих доступ к критичной информации, потребуется одновременное присутствие двух сотрудников. Таким образом, Database Vault решает следующие проблемы:
-	ограничение доступа к данным администратора БД и других привилегированных пользователей; 
-	предотвращение манипулирования с базой данных и обращения к другим приложениям администратора приложений; 
-	обеспечение контроля над тем, кто, когда и откуда может получить доступ к приложению.
 
2) Защита доступа 
Аутентификация в контексте Oracle означает проверку подлинности кого-либо или чего-либо - пользователя, приложения, устройства, кому или чему требуется доступ к данным, ресурсам или приложениям. После успешной процедуры аутентификации следует процесс авторизации, предполагающий назначение определенных прав, ролей и привилегий для субъекта аутентификации.
Oracle предоставляет разнообразные способы аутентификации и позволяет применять один или несколько из них одновременно. Общим для всех этих способов является то, что качестве субъекта аутентификации используется имя пользователя. Для подтверждения его подлинности может запрашиваться некоторая дополнительная информация, например, пароль. Программное обеспечение Oracle также зашифровывает пароли пользователей для безопасной передачи по сети.

Виды аутентификации:
а) Аутентификация средствами операционной системы 
Ряд операционных систем позволяют СУБД Oracle использовать информацию о пользователях, которыми управляет ОС. В этом случае пользователь компьютера имеет доступ к ресурсам БД без дополнительного указания имени и пароля - используются его сетевые учетные данные. Данный вид аутентификации считается небезопасным и используется, в основном, для аутентификации администратора СУБД.
б) Аутентификация при помощи сетевых сервисов 
Данный вид аутентификации обеспечивает опция сервера Oracle Advanced Security. Она предоставляет следующие службы:
-	аутентификация с использованием протокола SSL
-	аутентификация службами третьих сторон: Kerberos, PKI, RADIUS (Remote Authentication Dial - In User Service), LDAP
в) Аутентификация в многоуровневых приложениях
Приведенные выше методы аутентификации также могут быть применены и в многоуровневых приложениях. Как правило, для доступа к приложениям из сети Интернет используется аутентификация по имени и паролю (в том числе с использованием протокола RADIUS), либо по протоколу SSL. Прочие методы используются для работы пользователей в локальной сети.

3) Шифрование данных 
Для защиты данных, передаваемых в сети, в СУБД Oracle, начиная с версии 8i, используется возможности опции Oracle Advanced Security, в которой предусмотрена функция Network encryption, позволяющая шифровать весь поток данных. Безопасность информации обеспечивается секретностью ключа, которым шифруются данные. Поддерживаются следующие алгоритмы шифрования: AES(только 10g /11g), DES, 3DES, RC 4(только 10g /11g).
Защита передаваемых в сети данных в приложениях Oracle обеспечивается протоколом SSL по алгоритмам, которые поддерживается сервером приложений, как правило, это WEB-сервер Oracle.
Защиту данных на носителе обеспечивают два компонента СУБД Oracle - пакеты, реализующие алгоритмы шифрования и опция Transparent Data Encryption (TDE). Управление ключами шифрования берет на себя ядро БД, а применение такого шифрования не требует переделки клиентского и серверного прикладного ПО.

4) Аудит доступа к данным 
СУБД Oracle имеет мощные средства аудита действий пользователей, включающих как доступ к данным, так и события регистрации/выхода и изменения структуры БД. Начиная с версии 9i, СУБД оснащается опцией подробного аудита (Fine Grained Audit Control), которая позволяет проводить аудит доступа по условиям с достаточно гибкими настраиваемыми правилами. Однако, данные средства аудита не позволяет проследить за действиями, которые совершаются администратором базы данных, а также не мешают ему изменять журнал аудита, удаляя любые строки и не оставляя следов подобных действий. Возникшая необходимость аудита деятельности и защиты данных аудита от привилегированных пользователей, включая администраторов БД, побудило Oracle разработать новую концепцию аудита. В её основу положена идея, на которой базируется функционал Database Vault: администратор БД изолирован от управления аудитом, что по понятным причинам обеспечивает более высокий уровень безопасности БД.

@Модель удаленного доступа к данным:
В данной модели компонент доступа к данным реализуется в виде самостоятельной программной части СУБД, называемой SQL-сервером, и размещается на сервере. SQL-сервер выполняет низкоуровневые операции по организации, размещению, хранению и манипулированию данными. На сервере размещаются также файлы БД и системный каталог БД. На клиентских установках размещаются программы, реализующие интерфейсные и прикладные функции СУБД. Прикладной компонент клиента формирует необходимые SQL-инструкции и направляет их SQL-серверу, который принимает, интерпретирует, выполняет, проверяет эти инструкции, обеспечивает выполнение ограничений целостности и безопасности данных и направляет клиентам результаты обработки SQL-инструкций (наборы данных). 
Достоинства: в результате реализации такого подхода резко уменьшается загрузка сети. Модель позволяет также унифицировать интерфейс взаимодействия прикладных компонентов СУБД с общими данными. Такое взаимодействие стандартизовано в рамках языка SQL специальным протоколом ODBC, играющим важную роль в обеспечении независимости от типа СУБД на клиентских установках. Это позволяет интегрировать уже существующие локальные БД в создаваемые распределенные информационные системы независимо от типов СУБД клиентов и сервера. 
Недостатки: высокие требования к клиентским вычислительным установкам, так как на них выполняются прикладные программы обработки данных. Значительный трафик сети, поскольку с сервера направляются клиентам наборы данных, которые могут иметь существенный объем.

@Технологии тиражирования (реплицирования) данных:
Основная идея тиражирования: пользователи работают автономно с одинаковыми (общими) данными, растиражированными по локальным базам данных, что обеспечивает в силу отсутствия необходимости передачи растиражированных данных максимальную производительность используемой вычислительной системы.
Реплика – тиражируемая копия данных, предназначенных для общего пользования.

При реализации технологии тиражирования данных возникает проблема обеспечения согласованного состояния данных, т.е. согласованного состояния во всех репликах количества и значений общих данных, а также структуры данных. Решение проблемы обеспечения согласованного состояния количества и значений общих данных основывается на реализации одного из двух принципов:
-	принципа непрерывного размножения обновлений (любое обновление данных в любой реплике должно быть немедленно размножено). Данный принцип реализуется при построении систем реального времени. Реализация этого принципа заключается в том, что любая транзакция считается успешно завершенной, если она успешно завершена во всех репликах. На практике реализации данного принципа препятствует возникновение тупиков. Для обнаружения и распознавания тупиков в реплицированных системах применяются те же алгоритмы, что и в мониторах транзакций централизованных систем типа «клиент-сервер».
-	принципа отложенных обновлений (обновления реплик могут откладываться до специальной команды или ситуации). Накопленные в реплике изменения данных специальной командой пользователя направляются для обновления всех остальных реплик системы. Такая операция называется синхронизацией реплик. В данном случае существенно снижается возможность конфликтов и тупиков. Для реализации процесса синхронизации реплик в системном каталоге БД создаются специальные таблицы текущих изменений и организуется система глобальной идентификации (именования) всех объектов распределенной системы, включая раздельное поименование одинаковых объектов в разных репликах (вплоть до записей таблиц). Такой подход несколько увеличивает объем БД, но позволяет значительно сократить транспортные расходы на синхронизацию реплик.

Решение проблемы обеспечения согласованности структуры данных основывается на технике главной реплики, суть которой заключается в следующем. Одна из реплик БД системы объявляется главной, причем изменять структуру данных можно только в этой главной реплике. Изменения в структуре данных в главной реплике тиражируются по принципу отложенных обновлений, т.е. с помощью синхронизации реплик. Выход из строя главной реплики не влечет за собой гибель всей распределенной информационной системы, так как остальные реплики продолжают функционировать автономно, что позволяет администратору системы преобразовать любую реплику в главную и тем самым восстановить работоспособность всей системы. 
Наряду с техникой главной реплики существует возможность создания частичных реплик. Частичной репликой называется база данных, содержащая ограниченное подмножество записей главной (полной) реплики. Распространенным способом создания частичных реплик является использование фильтров, устанавливаемых для таблиц главной реплики. Такой подход позволяет решать некоторые проблемы по разграничению доступа к данным, повысить производительность обработки данных и снизить затраты на синхронизацию реплик за счет ограничения количества передаваемых по сети изменений данных.

@Синхронизация данных:
В распределенных БД часто возникает проблема согласования данных, которые хранятся на различных компьютерах и в разных БД. Для решения ее разработчики БД интегрируют специальные приложения для синхронизации разрозненных данных, которые называются механизмами тиражирования. Механизм тиражирования должен обеспечить либо целостность данных в разных частях распределенной системы, либо их автономную работу.

### Для ознакомления
Применение PKI для аутентификации предполагает издание цифровых сертификатов для пользователей (приложений), которые используются для непосредственной аутентификации на серверах БД в рамках одной организации. При этом не требуется использование дополнительного сервера аутентификации.
СУБД Oracle поддерживает протокол RADIUS - стандартный протокол для аутентификации удаленных пользователей. При этом становятся доступны службы и устройства аутентификации третьих производителей, с которыми может взаимодействовать сервер RADIUS (например, устройства генерации одноразовых паролей, биометрические устройства и т.п.).
Использование службы LDAP-каталога делает управление аутентификацией и управление учетными записями пользователей (приложений) очень эффективным. В инфраструктуре СУБД Oracle служба каталога представлена следующими компонентами:
-	Oracle Internet Directory (OID) позволяет централизованно хранить и управлять информацией о пользователях (т.н. enterprise -пользователях). Позволяет иметь единственную учетную запись пользователя для многих баз данных. Возможна интеграция со службами каталогов третьих производителей, например, MS Active Directory или iPlanet . OID позволяет гибко управлять атрибутами безопасности и привилегиями каждого пользователя, включая тех, кто аутентифицируется по цифровым сертификатам. Для повышения безопасности во время процесса аутентификации возможно использование SSL -протокола.
-	Oracle Enterprise Security Manager - утилита управления пользователями, группами, ролями и привилегиями.


################################################################################

69.	Уголовно-правовая характеристика состава преступлений, предусмотренных ст. 272-274 Уголовного кодекса РФ
Терминология:
Уголовное право — это отрасль права, регулирующая общественные отношения, связанные с совершением преступных деяний, назначением наказания и применением иных мер уголовно-правового характера, устанавливающая основания привлечения к уголовной ответственности либо освобождения от уголовной ответственности и наказания.
Состав преступления – совокупность предусмотренных законом объективных и субъективных признаков, характеризующих совершенное общественно-опасное деяние как конкретный вид преступления. Состав преступления – необходимое основание уголовной ответственности. Состав преступления образуют четыре группы признаков, характеризующие объект преступления, его объективную сторону, субъект преступления и субъективную сторону.
Объект преступления – элемент состава преступления, конкретные охраняемые уголовным законом общественные отношения, на которые посягается виновный. 
Объективная сторона преступления – совершенные виновным конкретные действия (бездействие), представляющие общественную опасность и запрещенные  УК.
Субъект преступления – элемент состава преступления, вменяемое физическое лицо, достигшее предустановленного уголовным законом возраста.
Субъективная сторона преступления – психическое отношение лица к совершаемому или общественно опасному деянию.

Преступления в сфере компьютерной информации — общественно опасные деяния, совершаемые в сфере компьютерной информации, признаваемые преступлениями уголовным законодательством. В соответствии с действующим уголовным законодательством Российской Федерации под преступлениями в сфере компьютерной информации понимаются совершаемые в сфере информационных процессов и посягающие на информационную безопасность деяния, предметом которых являются информация и компьютерные средства.
По УК РФ преступлениями в сфере компьютерной информации являются: 
-	неправомерный доступ к компьютерной информации (ст. 272 УК РФ);
-	создание, использование и распространение вредоносных программ для ЭВМ (ст. 273 УК РФ);
-	нарушение правил эксплуатации ЭВМ, системы ЭВМ или их сети (ст. 274 УК РФ).

Общественная опасность противоправных действий в области электронной техники и информационных технологий выражается в том, что они могут повлечь за собой нарушение деятельности автоматизированных систем управления и контроля различных объектов, серьёзное нарушение работы ЭВМ и их систем, несанкционированные действия по уничтожению, модификации, искажению, копированию информации и информационных ресурсов, иные формы незаконного вмешательства в информационные системы, которые способны вызвать тяжкие и необратимые последствия, связанные не только с имущественным ущербом, но и с физическим вредом людям.
Неправомерный доступ к компьютерной информации (ст. 272 УК РФ), а также создание, использование и распространение вредоносных программ для ЭВМ (ст. 273 УК РФ) совершаются только путём действий, в то время как нарушение правил эксплуатации ЭВМ, системы ЭВМ или их сети (ст. 274 УК РФ) — путём как действий, так и бездействием.
Неправомерный доступ к компьютерной информации и нарушение установленных правил эксплуатации ЭВМ, системы ЭВМ или их сети сформулированы как преступления с материальным составом, а создание либо использование вредоносных программ для ЭВМ — с формальным. В качестве последствий в ст. 272 и 274 УК указываются: уничтожение, модификация, блокирование либо копирование информации, нарушение работы ЭВМ или системы ЭВМ, причинение существенного вреда и т. п.
Родовым объектом преступлений в сфере компьютерной информации является общественная безопасность и порядок в отношениях, связанных с информационными процессами - процессами сбора, обработки, накопления, хранения, поиска и распространения информации, с использованием ЭВМ, их систем и сетей. Существенно то, что предметом данных преступлений является компьютерная информация, а не информационное оборудование, обеспечивающее информационные процессы. Правонарушения, совершенные в ходе данных процессов, не связанные с использованием указанного оборудования, квалифицируются с помощью иных статей УК РФ, предусматривающих ответственность за соответствующие конкретные действия. 
Непосредственным объектом данных преступных деяний является безопасность информационных систем, базирующихся на использовании ЭВМ, системе ЭВМ или их сети.
Объективная сторона компьютерных преступлений характеризуется как действием, так и бездействием. Действие (бездействие) сопряжено с нарушением прав и интересов по поводу пользования компьютерной информацией. 
Компьютерные преступления имеют материальные составы. Действие (бездействие) должно причинить значительный вред правам и интересам личности, общества или государства (исключением является преступление с формальным составом, предусмотренное ч. 1 ст.273 УК: создание, использование и распространение вредоносных программ для ЭВМ). Преступные последствия конкретизируются в законе применительно к конкретным видам компьютерных преступлений. Между деянием и последствиями обязательно должна быть установлена причинная связь. 
Субъективная сторона компьютерных преступлений характеризуется умышленной виной. В ч. 2 ст. 24 сказано, что деяние совершенное по неосторожности признается преступлением только тогда, когда это специально предусмотрено соответствующей статьей Особенной части УК. Неосторожная форма вины названа в Особенной части лишь применительно к квалифицированным видам компьютерных преступлений, предусмотренных в ч. 2 ст. 273 и ч.2 ст. 274 УК. 
Субъект компьютерного преступления общий - лицо, достигшее 16 лет. В ст. 274 и в ч. 2 ст. 272 УК формулируются признаки специального субъекта: лицо, имеющее доступ к ЭВМ, системе ЭВМ или их сети. 
Преступление в сфере компьютерной информации - это предусмотренное уголовным законом виновное нарушение чужих прав и интересов в отношении автоматизированных систем обработки данных, совершенное во вред подлежащим правовой охране правам и интересам физических и юридических лиц, общества и государства.

Статья 272. Неправомерный доступ к компьютерной информации 
1. Неправомерный доступ к охраняемой законом компьютерной информации, то есть информации на машинном носителе, в электронно-вычислительной машине (ЭВМ), системе ЭВМ или их сети, если это деяние повлекло уничтожение, блокирование, модификацию либо копирование информации, нарушение работы ЭВМ, системы ЭВМ или их сети, - наказывается штрафом в размере от двухсот до пятисот минимальных размеров оплаты труда или в размере заработной платы или иного дохода осужденного за период от двух до пяти месяцев, либо исправительными работами на срок от шести месяцев до одного года, либо лишением свободы на срок до двух лет. 
2. То же деяние, совершенное группой лиц по предварительному сговору или организованной группой либо лицом с использованием своего служебного положения, а равно имеющим доступ к ЭВМ, системе ЭВМ или их сети, - наказывается штрафом в размере от пятисот до восьмисот минимальных размеров оплаты труда или в размере заработной платы или иного дохода осужденного за период от пяти до восьми месяцев, либо исправительными работами на срок от одного года до двух лет, либо арестом на срок от трех до шести месяцев, либо лишением свободы на срок до пяти лет.

Статья 273. Создание, использование и распространение вредоносных программ для ЭВМ 
1. Создание программ для ЭВМ или внесение изменений в существующие программы, заведомо приводящих к несанкционированному уничтожению, блокированию, модификации либо копированию информации, нарушению работы ЭВМ, системы ЭВМ или их сети, а равно использование либо распространение таких программ или машинных носителей с такими программами - наказываются лишением свободы на срок до трех лет со штрафом в размере от двухсот до пятисот минимальных размеров оплаты труда или в размере заработной платы или иного дохода осужденного за период от двух до пяти месяцев. 
2. Те же деяния, повлекшие по неосторожности тяжкие последствия, - наказываются лишением свободы на срок от трех до семи лет.

Статья 274. Нарушение правил эксплуатации ЭВМ, системы ЭВМ или их сети 
1. Нарушение правил эксплуатации ЭВМ, системы ЭВМ или их сети лицом, имеющим доступ к ЭВМ, системе ЭВМ или их сети, повлекшее уничтожение, блокирование или модификацию охраняемой законом информации ЭВМ, если это деяние причинило существенный вред, - наказывается лишением права занимать определенные должности или заниматься определенной деятельностью На срок до пяти лет, либо обязательными работами на срок от ста восьмидесяти до двухсот сорока часов, либо ограничением свободы на срок до двух лет. 
2. То же деяние, повлекшее по неосторожности тяжкие последствия, - наказывается лишением свободы на срок до четырех лет.

################################################################################

83.        Протокол SSL
Отличная статья от ИТМО:
https://neerc.ifmo.ru/wiki/index.php?title=SSL/TLS

################################################################################

84.        Протокол Kerberos
Kerberos — сетевой протокол аутентификации, позволяющий передавать данные через незащищённые сети для обеспечения безопасной идентификации. Ориентирован, в первую очередь, на клиент-серверную модель и обеспечивает взаимную аутентификацию — оба пользователя подтверждают личности друг друга через доверенный сервер. Данная модель является одним из вариантов протокола аутентификации Нидхема — Шрёдера на основе доверенной третьей стороны.

@Общие сведения:
-        протокол Kerberos был специально разработан для того, чтобы обеспечить надежную аутентификацию пользователей;
-        предусматривается, что начальный обмен информацией между клиентом и сервером происходит в незащищённой среде, а передаваемые пакеты могут быть перехвачены и модифицированы;
-        протокол Kerberos может использовать централизованное хранение аутентификационных данных и является основой для построения механизмов Single Sign-On (возможность использования единой учетной записи пользователя для доступа к любым ресурсам области);
-        протокол основан на понятии Ticket (билет). Ticket (билет) является зашифрованным пакетом данных, который выдается доверенным центром аутентификации, в терминах протокола Kerberos — Key Distribution Center (KDC, центр распределения ключей);
-        когда пользователь выполняет первичную аутентификацию, после успешного подтверждения его подлинности KDC выдает первичное удостоверение пользователя для доступа к сетевым ресурсам — Ticket Granting Ticket (TGT). В дальнейшем, при обращении к отдельным ресурсам сети, пользователь, предъявляя TGT, получает от KDC удостоверение для доступа к конкретному сетевому ресурсу — Service Ticket (TGS);
-        одним из преимуществ протокола Kerberos, обеспечивающим высокий уровень безопасности, является то, что при любых взаимодействиях не передаются ни пароли, ни значения хеша паролей в открытом виде;
-        работая с протоколом Kerberos, необходимо, чтобы системные часы всех участвующих во взаимодействии узлов были синхронизированы;
-        в качестве примера реализации протокола Kerberos имеет смысл отметить доменную аутентификацию пользователей в операционных системах Microsoft, начиная с Windows 2000.

@Процесс работы с протоколом Kerberos (кратко):
Пользователь регистрируется на своей рабочей станции, которая обрабатывает последовательность сообщений AS_REQ и AS_REP с центром KDC, откуда пользователь получает билет TGT, если учетные данные верны. Затем TGT пользователя кэшируется в памяти, и каждый раз, когда пользователю нужно получить доступ к службе (например, к серверу файлов, серверу печати, веб-приложению), пользователь предъявляет TGT центру KDC и запрашивает билет службы для конкретной службы. Пользователь получает билет службы и предъявляет его приложению, чтобы запросить доступ.
Схематично:
 ___________________                    ___________________                    ___________________
|                   |                  |                   |                  |                   |
|                   |                  |                   |>>>  1 AS_REQ  >>>|                   |
|       Сервер      |<<<  5 AP_REQ  <<<|       Клиент      |<<<  2 AS_REP  <<<|        KDC        |
|     приложений    |>>>  6 AP_REP  >>>|                   |>>>  3 TGS_REQ >>>|     (AS + TGS)    |
|                   |                  |                   |<<<  4 TGS_REP <<<|                   |
|___________________|                  |___________________|                  |___________________|

AS        ==        Authentication Server
TGS        ==        Ticket Granting Server
В процессее повествования отмечаю оба сервера как один - KDC, но на практике они могут рассматриваться как различные: в таком случае за процесс аутентификации отвечает сервер AS, а процесс выдачи билетов обеспечивает TGS. Просто заметка)

@Проверка подлинности:
-        после того, как пользователь вводит имя и пароль на клиентской машине, эта машина хеширует введенный пароль. Полученный хеш становится секретным ключом клиента;
-        для проверки подлинности введенных данных в KDC отправляется сообщение AS_REQ (Authentication Service Request). Для защиты от атаки с повторной передачей пакетов текущее время шифруется с использованием хеша пароля пользователя. Допустимое расхождение времени при этом (по умолчанию) - 5 минут. Элементы запроса AS_REQ представлены ниже:
   ___________________________
  |                           |
  |   ----------------------  |
  |  |     Имя клиента      | |
  |   ----------------------  |
  |  |  Имя службы(krbtgt)  | |
  |   ----------------------  | 
  |  #  Время клиента(шифр.)# |
  |   ----------------------  |
  |___________________________|
              AS_REQ
            
-        когда KDC получает запрос AS_REQ, он в первую очередь пытается расшифровать отметку времени с использованием локальной копии хеша пароля пользователя. Если попытка заканчивается неудачей, клиент получает сообщение об ошибке, и обработка запроса прекращается. Если расшифрование происходит удачно И значение отметки времени находится в допустимых пределах, KDC отправляет пользователю сообщение AS_REP (Authentication Service Reply) со встроенным билетом TGT (Ticket Granting Ticket). Ответ AS_REP содержит в себе имя пользователя и два блока зашифрованных данных: первый блок шифруется с применением хеша пароля пользователя и содержит сеансовый ключ и отметку времени окончания существования билета (10 часов по умолчанию); а второй блок шифруется при помощи секрета KDC, который хранится в Active Directory как пароль для учетной записи krbtgt. Элементы ответа AS_REP представлены ниже:
 ____________________________________
|       -----------------------      |
|      |      Имя клиента      |     |
|       -----------------------      |
|   ------------------------------   |
|  #                              #  |
|  #    ------------------------  #  |
|  #   |       Ключ сессии      | #  |
|  #    ------------------------  #  |
|  #   | Время жизни/истечения  | #  |
|  #    ------------------------  #  |
|  #                              #  |
|   ------------------------------   |
|                                    |
|   ------------------------------   |
|  $                              $  |
|  $    ------------------------  $  |
|  $   |       Ключ сессии      | $  |
|  $    ------------------------  $  |
|  $   |   Информация маркера   | $  |
|  $    ------------------------  $  |
|  $   | Время жизни/истечения  | $  |
|  $    ------------------------  $  |
|  $               TGT            $  |
|   ------------------------------   |
|____________________________________|    
                AS_REP

Сеансовый ключ используется для шифрования будущих соединений с центром KDC. После получения AS_REP компьютер сохраняет в кэше билет TGT и сеансовый ключ на время существования TGT, а затем удаляет хеш пароля пользователя.

@Получение билета службы:
-        в Kerberos любой объект, к которому требуется получить доступ, называется службой (например, серверы файлов и печати, серверы базы данных, внутренние веб-приложения). Для доступа к службе пользователь предоставляет билет службы. Перед этим компьютер или приложение пользователя определяет имя участника службы service principal name (SPN), к которой нужно получить доступ.
-        для получения билета службы клиент обращается к KDC, отправляя ему запрос TGS_REQ (Ticket Granting Service Request). Первый фрагмент информации в запросе - имя SPN службы, для которой клиент запрашивает билет. Второй фрагмент - имя клиента и отметка текущего времени - шифруются с помощью сеансового ключа, полученного из AS_REP. Третий фрагмент - экземпляр билета TGT, полученного ранее также из AS_REP, зашифрованный при помощи секрета KDC. Элементы запроса TGS_REQ представлены ниже:
 ____________________________________
|       -----------------------      |
|      |           SPN         |     |
|       -----------------------      |
|   ------------------------------   |
|  #                              #  |
|  #    ------------------------  #  |
|  #   |       Имя клиента      | #  |
|  #    ------------------------  #  |
|  #   |     Отметка времени    | #  |
|  #    ------------------------  #  |
|  #                              #  |
|   ------------------------------   |
|                                    |
|   ------------------------------   |
|  $                              $  |
|  $    ------------------------  $  |
|  $   |       Ключ сессии      | $  |
|  $    ------------------------  $  |
|  $   |   Информация маркера   | $  |
|  $    ------------------------  $  |
|  $   | Время жизни/истечения  | $  |
|  $    ------------------------  $  |
|  $               TGT            $  |
|   ------------------------------   |
|____________________________________|    
                TGS_REQ

                
-        после получения запроса TGS_REQ KDC проверяет, что указан один элемент для SPN, отметка времени находится в допустимом диапазоне и билет TGT не просрочен. Если все условия выполнены, то клиенту отправляется ответ TGS_REP, содержащий в себе зашифрованный билет службы. Первый блок TGS_REP шифруется при помощи сеансового ключа. Билет службы шифруется с помощью секрета службы (например, пароля учетной записи компьютера или учетной записи службы). Клиент кэширует билет службы и использует всегда, когда необходим доступ к службе. Так же, как у билетов TGT, время, в течение которого разрешено повторно использовать билеты службы, ограничено (десять часов по умолчанию в реализации Kerberos в AD). Имея билет службы, клиент может запросить доступ к ней. Элементы ответа TGS_REP представлены ниже:
 ____________________________________
|   ------------------------------   |
|  #                              #  |
|  #    ------------------------  #  |
|  #   |           SPN          | #  |
|  #    ------------------------  #  |
|  #   |     Отметка времени    | #  |
|  #    ------------------------  #  |
|  #   |   Ключ сессии службы   | #  |
|  #    ------------------------  #  |
|  #                              #  |
|   ------------------------------   |
|                                    |
|   ------------------------------   |
|  $                              $  |
|  $    ------------------------  $  |
|  $   |       Имя клиента      | $  |
|  $    ------------------------  $  |
|  $   |          SPN           | $  |
|  $    ------------------------  $  |
|  $   |   Ключ сессии службы   | $  |
|  $    ------------------------  $  |
|  $   |     Отметка времени    | $  |
|  $    ------------------------  $  |
|  $         Билет службы         $  |
|   ------------------------------   |
|____________________________________|    
                TGS_REP

@Доступ к службам:
-        после того, как клиент получает билет службы, приложение, обращающееся к службе, может предъявить этот билет службе и запросить доступ. Механика предъявления билета службы не так стандартизована, как получение билета, из-за различий, свойственных приложениям. Например, в случае со службой HTTP билет службы встраивается в заголовки запроса HTTP.
-        клиент отправляет запрос AP_REQ, содержащий в себе билет службы. Служба дешифрует билет службы и получает сеансовый ключ, который можно использовать для дешифрации первого блока данных: полей отметки времени и имени клиента, которые в свою очередь используются для проверки подлинности билета службы. Даже если служба принимает билет службы, на данном этапе клиент просто прошел проверку в службе. Выполнить задачу авторизации службе предстоит на основе информации о клиенте.
-        в билет службы также обычно входят данные, известные как сертификат атрибута привилегий Privilege Attribute Certificate (PAC). Это та же информация маркера, которую KDC включает в билет TGT пользователя. Сертификат PAC составлен из такой информации, как идентификатор безопасности (SID) пользователя, сведения о членстве в группе и правах безопасности/привилегиях пользователя. Когда пользователь предъявляет билет TGT в центр KDC, чтобы запросить билет службы, KDC копирует информацию маркера из TGT и вставляет в поле PAC билета службы. Служба использует эту информацию, чтобы подготовить маркер доступа для пользователя и проверить авторизацию пользователя, обычно на основе членства в группе.
-        допускается передача дополнительного сообщения Kerberos, известного как AP_REP или Application Reply, после того как пользователь предъявляет билет службы в сообщении AP_REQ. Сообщение Application Reply — необязательное; как правило, приложение не отправляет такое сообщение, если не происходит ошибки. Пример ситуации, когда формируется сообщение AP_REP: клиент запрашивает (в сообщении AP_REQ) у службы подтверждение подлинности для обоюдной проверки подлинности.
Элементы запроса AP_REQ представлены ниже:
 ____________________________________
|   ------------------------------   |
|  #                              #  |
|  #    ------------------------  #  |
|  #   |       Имя клиента      | #  |
|  #    ------------------------  #  |
|  #   |     Отметка времени    | #  |
|  #    ------------------------  #  |
|  #                              #  |
|   ------------------------------   |
|                                    |
|   ------------------------------   |
|  $                              $  |
|  $    ------------------------  $  |
|  $   |       Имя клиента      | $  |
|  $    ------------------------  $  |
|  $   |          SPN           | $  |
|  $    ------------------------  $  |
|  $   |   Ключ сессии службы   | $  |
|  $    ------------------------  $  |
|  $   |     Отметка времени    | $  |
|  $    ------------------------  $  |
|  $   |   Информация маркера   | $  |
|  $    ------------------------  $  |
|  $         Билет службы         $  |
|   ------------------------------   |
|____________________________________|        
                AP_REQ
 
################################################################################

85.        Алгоритм RSA. Принцип работы, взаимная обратность отображений шифрования и дешифрования, вопросы выбора параметров, приложения, основные виды атак.
RSA - криптографический алгоритм с открытым ключом, который основывается на вычислительной сложности задачи факторизации больших целых чисел. Используется в большом числе криптографических приложений (PGP, SSL/TLS, ...).

В криптографической системе с открытым ключом каждый участник располагает как открытым ключом, так и закрытым ключом. В криптографической системе RSA каждый ключ состоит из пары целых чисел. Каждый участник создаёт свой открытый и закрытый ключ самостоятельно. Закрытый ключ каждый из них держит в секрете, а открытые ключи можно сообщать кому угодно или даже публиковать их. Открытый и закрытый ключи каждого участника обмена сообщениями в криптосистеме RSA образуют «согласованную пару» в том смысле, что они являются взаимно обратными, то есть:
∀ допустимых пар открытого и закрытого ключей (p, s)
    ∃ соответствующие функции шифрования E(x) и расшифрования D(x) такие, что
        ∀ сообщения m ∈ M, где M — множество допустимых сообщений,
            m = D(E(m)) = E(D(m)).

Алгоритм создания ключей:
1) Выбираются два различных случайных простых числа p и q заданного размера (например, 2048 бит каждое)
2) Вычисляется их произведение N = p * q, которое называется модулем
3) Вычисляется значение функции Эйлера от числа N: φ(N) = (p - 1) * (q - 1)
4) Выбирается целое число e (1 < e < φ(N)), взаимно простое с φ(N). Число e называется открытой экспонентой, и в качестве значения выбирают простые числа, содержащие небольшое количество единичных бит в двоичной записи (прим. 65537), благодаря чему время шифрования с использованием быстрого возведения в степень будет значительно меньше
5) Вычисляется число d, мультипликативно обратное к числу e по модулю φ(N), то есть число, удовлетворяющее сравнению: d * e = 1 (mod φ(N))
6) Пара (e, N) публикуется в качестве открытого ключа RSA
7) Пара (d, N) играет роль закрытого ключа RSA и хранится в секрете

Шифрование:
с = m^e (mod N)
Расшифрование:
m = c^d (mod N)

Система RSA может использоваться не только для шифрования, но и для цифровой подписи. Предположим, что Алисе (стороне A) нужно отправить Бобу (стороне B) сообщение m, подтверждённое электронной цифровой подписью. Тогда для Алисы алгоритм будет следующим:
1) Взять открытый текст m
2) Создать цифровую подпись с помощью своего секретного ключа: s = m^d (mod N)
3) Передать пару {m, s} Бобу

Алгоритм для Боба:
1) Принять пару {m, s}
2) Взять открытый ключ {e, N} у Алисы
3) Вычислить прообраз сообщения из полученной подписи: m' = s^e (mod N)
4) Проверить неизменность сообщения, сравнив m и m'
Цифровая подпись обеспечивает как аутентификацию автора сообщения, так и подтверждение целостности содержимого подписанного сообщения.

О выборе параметров p и q: 
-        для исключения возможностей применения методов факторизации накладываются следующие ограничения: числа p1 = (p - 1)/2, p2 = (p + 1)/2, q1 = (q - 1)/2, q2 = (q + 1)/2 должны быть простыми, причем p1 - 1 и q1 - 1 не должны разлагаться на произведение маленьких простых чисел.

О выборе параметров e и d:
-        при использовании малого значения параметра e искомое сообщение можно найти путем извлечения корня степени e
-        при использовании малого значения параметра d искомое сообщение можно будет найти путем перебора малых значений до получения корректного расшифрованного сообщения

Атаки на алгоритм RSA:
https://ru.wikipedia.org/wiki/Криптоанализ_RSA

################################################################################

86. Методы факторизации натуральных чисел
https://ru.wikipedia.org/wiki/Факторизация_целых_чисел
http://old.kpfu.ru/f9/bibl/Monograph_ishm.pdf

################################################################################

87.	Сравнительная характеристика моделей OSI и TCP/IP


################################################################################

96. Вредоносные программы: классификация, основные характеристики, современные тенденции в развитии вредоносных программ
Вредоносная программа – программа, используемая для осуществления несанкционированного доступа к информации и (или) воздействия на информацию или ресурсы автоматизированной информационной системы (из ГОСТ 51275-2006 Защита информации. Объект информатизации…).
Классификация вредоносных программ:
1)        Вирус – самовоспроизводящийся программный код, который внедряется в установленные программы без согласия пользователя. В дополнение к этому вирус может быть запрограммирован на выполнение вредоносных действий (например, удаление или порча файлов) и самомодификацию. Примеры: Virus 1, 2, 3, Elk Cloner, «Чернобыль».
2)        Червь – саморазмножающаяся программа, которая поселяется на компьютер жертвы, а затем ищет уязвимости в Сети или системе для дальнейшего распространения себя. Некоторые черви существуют в виде сохраненных на жестком диске файлов, а некоторые поселяются в оперативной памяти компьютера. Примеры: червь Морриса, Stuxnet, Wanna Cry.
3)        Троян – вредоносная программа, которая отличается от самопроизвольно распространяющихся вирусов и червей тем, что она распространяется злоумышленниками. Большинство троянских программ маскируется под безвредные или полезные программы, чтобы пользователь загрузил/установил их на свой компьютер. Злоумышленники помещают троянские программы на открытые и индексируемые ресурсы, носители информации, присылают их предполагаемым жертвам по электронной почте, также трояны устанавливаются на компьютер через бреши безопасности. Примеры: Trojan.Spy, Trojan.Downloader, Trojan.SMS.
4)        Руткит – вредоносная программа, специально разработанная для сокрытия присутствия вредоносного кода  и его действий от пользователя и установленного защитного программного обеспечения. Некоторые руткиты могут начинать свою работу прежде, чем загрузится операционная система (буткит). Примеры: Blue Pill, Haxdoor, Mebroot. 
5)        Бэкдор (средство удаленного администрирования) – приложение, которое позволяет злоумышленнику управлять компьютером на расстоянии. В зависимости от функциональных особенностей конкретного бэкдора, злоумышленник может установить и запустить на компьютере любое программное обеспечение, сохранять все нажатия клавиш, загружать и сохранять файлы, делать снимки с веб-камеры и т.п. Примеры: Linux.Backdoor.*, Python.Backdoor.*, Backdoor:MSIL/Sorcas.A.
6)        Загрузчик – небольшая программа, которая используется лишь для дальнейшей загрузки и установки полной версии вредоносной программы. После того, как загрузчик попадает на компьютер жертвы (например, после открытия вложения из полученного письма), он соединяется с удаленным сервером и загружает всю вредоносную программу. Пример: Nemucode.
7)        Вредоносные утилиты – программы, разработанные для автоматизации создания других вредоносных программ, организации DoS-атак на удаленные сервера, взлома компьютеров и т.д. В отличие от предыдущих категорий, такие программы не представляют угрозы компьютеру, на котором исполняются. Примеры: Email-Flooder, DoS, Spoofer.
8)        Нежелательное ПО – программы, которые по своей сути не являются вредоносными, но в большинстве случаев могут надоедать пользователю. Примеры: AdWare, SpyWare, zip-bomb.

Основные характеристики вредоносных программ:
−        целевая среда. Устройства, операционные системы, приложения и т.п.;
−        механизм передачи. Съемные носители, общие сетевые диски, сеть, электронная почта и т.п.;
−        вредоносные действия. Порча, уничтожение, хищение информации, отказ в обслуживании и т.п.;
−        механизмы активации. Ручной (социальная инженерия), полуавтоматический, автоматический (в том числе по событию);
−        механизмы защиты. Обфускация, упаковка, генерация мусора, олигоморфизм, полиморфизм, метаморфизм, обратные атаки на антивирусное программное обеспечение.

Современные тенденции в развитии вредоносных программ:
−        использование техники «living off the land». Злоумышленники, чтобы избежать обнаружения, всё чаще используют программы, которые уже установлены у жертв. Так, например, NotPetya распространялся по сети благодаря утилите PSExec и инструментария управления Windows (WMI). Эти инструменты не классифицируются как угрозы, потому что являются легитимным программным обеспечением, и поэтому не детектируются сканерами;
−        использование «plug-and-play» червей. Злоумышленники после инцидента с WannaCry стали намного чаще полагаться на возможности распространения червей по сети и их последующее закрепление в системе путем планирования задач и формирования бэкдоров;
−        использование аппаратных уязвимостей для проведения атак. После обнаружения уязвимостей Meltdown и Spectre, позволяющих вредоносным приложениям получать доступ к конфиденциальным данным из памяти, злоумышленники выделили их в качестве приоритетных. По материалам ЛК, отдельные APT группировки уже тестируют образцы вредоносных программ, использующих эти уязвимости. 
Дополнительно можно рассказать про внимание к IoT устройствам и увеличению количества вредоносных программ для мобильных устройств.

################################################################################

97. Компьютерные вирусы: классификация, основные характеристики, способы внедрения в программный код, способы сокрытия факта заражения и основные демаскирующие признаки
Компьютерный вирус – самовоспроизводящийся программный код, который внедряется в установленные программы без согласия пользователя. В дополнение к этому вирус может быть запрограммирован на выполнение вредоносных действий (например, удаление или порча файлов) и самомодификацию.

Классификация вирусов:
1)        По целевой среде
-        компьютерные вирусы для различных аппаратных платформ (вирусы для определенной аппаратной платформы, межплатформные вирусы, платформно-независимые вирусы (вирусы виртуальных машин – Java-вирусы, .NET-вирусы));
-        компьютерные вирусы для различных операционных систем (вирусы для определенных ОС, переносимые вирусы (за счет бинарной совместимости ОС, за счет переносимости исходного кода, например, скрипт-вирусы)).
2)        По объекту-носителю
-        вирусы для исполняемых файлов (COM-вирусы, EXE-вирусы (различают MZ-, PE-вирусы), COFF/ELF-вирусы);
-        вирусы для исполняемых объектов (COM/ActiveX-вирусы, Java-вирусы, .NET-вирусы);
-        загрузочные вирусы;
-        скрипт-вирусы;
-        макровирусы;
-        комбинированные.

Выбор объекта-носителя может происходить следующим образом:
-        произвольная жертва (заражется всё подряд);
-        по определенным критериям (заражение происходит, например, только определенных ОС);
-        только конкретные объекты (например, только PE-файлы).
3)        По способу заражения
-        классические вирусы (внедряются в объект-носитель, стараясь максимально скрыть своё присутствие);
-        "вандалы" (внедряются в объект-носитель, не стараясь скрыть своё присутствие, могут повредить объект-носитель);
-        "спутники" (существуют в виде отдельного объекта "рядом" с носителем, заражения как такового не происходит).
4)        По принципу выбора жертвы
-        вирусы-сканеры (определяют жертву в момент своей активации);
-        вирусы-мониторы (отслеживают активность потенциальных объектов-носителей с целью определения возможности заражения).
5)        По размещению в системе
-        резидентный вирус при заражении компьютера оставляет в оперативной памяти свою резидентную часть, которая потом перехватывает обращение операционной системы к объектам заражения (файлам, загрузочным секторам дисков и т.п.) и внедряется в них. Резидентные вирусы находятся в памяти и являются активными вплоть до выключения или перезагрузки компьютера;
-        нерезидентный вирус не заражает память компьютера и является активным ограниченное время. Активизируется в определенные моменты, например, при обработке документов текстовым редактором.
6)        По способу активации
-        ручная (социальная инженерия);
-        автоматическая (характерная для загрузочных вирусов, а также для файловых вирусов с возможностью автозапуска программы);
-        полуавтоматическая (характерная для "спутников");
-        логические бомбы (по наступлению определенного события);
-        временные бомбы (по наступлению определенного момента времени).
7)        По способу защиты от удаления
-        незащищенные вирусы;
-        зашифрованные вирусы (в том числе упаковка);
-        размазывание вируса (записывается в свободные участки объекта-носителя с использованием переходов);
-        обфускация;
-        олигоморфизм (низкий уровень защиты от сигнатурного поиска);
-        полиморфизм (средний уровень защиты от сигнатурного поиска);
-        метаморфизм (высокий уровень защиты от сигнатурного поиска);
-        активная защита (нападение на антивирусные средства, дополнительные средства от анализа).

Способы внедрения в программный код:
-        размещение X-кода поверх оригинальной программы (затирание);
-        размещение X-кода в свободном месте программы (интеграция);
-        дописывание X-кода в начало, середину или конец файла с сохранением оригинального содержимого;
-        размещение X-кода вне основного тела файла-носителя (например, в динамической библиотеке или NTFS-потоке), загружаемого "головой" X-кода, внедренной в файл способами 1-3.

Способы сокрытия факта заражения:
-        стелс-вирусы. При попытке чтения зараженного сектора диска эти вирусы "подставляют" вместо себя незараженный оригинал;
-        обфускация. Код вируса обрабатывается таким образом, что его становится сложно анализировать исследователю, но функциональность при этом сохраняется;
-        упаковка. Тело вируса сжимается и исполняется только после распаковки декриптором, который прикрепляется к упакованному телу вируса (примеры: UPX, ASpack);
-        генерация мусора. Код вируса "разбавляется" бесполезными инструкциями, которые затрудняют его анализ и мешают сигнатурному анализу;
-        пермутация. Перестановка логических блоков в теле вируса;
-        полиморфизм. Для упаковки вируса каждый раз используется новый ключ, зависимый, например, от объема файла, который он инфицирует;
-        метаморфизм. То же, что и полиморфизм, но в каждом поколении вирусов генерируется новый код декриптора, что мешает сигнатурному анализу;
-        "антипесочница". Вирус не проявляет (либо проявляет позднее) свои деструктивные свойства, если определяет окружающую среду как виртуальную.

Основные демаскирующие признаки:
-        наличие нетипичного стартового поведения в момент загрузки программы;
-        наличие известных сигнатур (в том числе строковые, который явно выдают присутствие вируса);
-        нетипичный набор секций, измененные имена секций;
-        нетипичные таблицы импорта.

################################################################################

98.        Антивирусные программы: классификация антивирусных программ, способы обнаружения и уничтожения вредоносного кода, характеристика современных антивирусных программ
Антивирусная программа - это программа, предназначенная для противодействия ВПО.

Классификация антивирусных программ:
1)        По средствам блокирования
-        программные;
-        программно-аппаратные.
2)        По размещению в оперативной памяти
-        резидентные (находятся в памяти компьютера и осуществляют автоматическую проверку файлов и происходящих событий);
-        нерезидентные (запускаются по требованию пользователя или по определенному расписанию).
3)        По способу защиты от ВПО
-        программы-детекторы (сканеры). Находят ВПО в оперативной памяти, на внутренних и(или) внешних носителях, выводя сообщение при обнаружении вируса;
-        программы-доктора (фаги). Находят зараженные файлы и "лечат" их, удаляя тело вируса из файла. Среди этого вида программ существуют полифаги, предназначенные для поиска и удаления разнообразных видов ВПО;
-        программы-вакцины (иммунизаторы). Выполняют "иммунизацию" системы (файлов, каталогов), блокируя возможное действие ВПО;
-        программы-ревизоры. Запоминают 
-        программы-мониторы. Начинают свою работу при запуске операционной системы, постоянно находятся в памяти компьютера и осуществляют автоматическую проверку файлов;
-        программы-фильтры. Резидентные программы, которые оповещают пользователя обо всех подозрительных действиях.

В соответствии с "Требованиями к средствам антивирусной защиты" ФСТЭК:
-        тип «А» – средства антивирусной защиты (компоненты средств антивирусной защиты), предназначенные для централизованного администрирования средствами антивирусной защиты, установленными на компонентах информационных систем (серверах, автоматизированных рабочих местах);
-        тип «Б» – средства антивирусной защиты (компоненты средств антивирусной защиты), предназначенные для применения на серверах информационных систем;
-        тип «В» – средства антивирусной защиты (компоненты средств антивирусной защиты), предназначенные для применения на автоматизированных рабочих местах информационных систем;
-        тип «Г» – средства антивирусной защиты (компоненты средств антивирусной защиты), предназначенные для применения на автономных  автоматизированных рабочих местах.
Средства антивирусной защиты типа «А» не применяются в информационных системах самостоятельно и предназначены для использования только совместно со средствами антивирусной защиты типов «Б» и (или) «В». 

Способы обнаружения и уничтожения вредоносного кода:
На территории Российской Федерации деятельность, связанная с обнаружением вредоносных программ и последующим их устранением определяется стандартом ГОСТ Р 51188-98. Согласно этому стандарту, при испытаниях программных средств на наличие вредоносного кода используются две основные группы методов обнаружения: программные и аппаратно-программные. К программным методам относятся:
1)        Сигнатурное сканирование – это один из самых простых методов обнаружения вредоносных программ, которой обычно применяется в первую очередь. Принцип его работы заключается в проверке содержимого анализируемого объекта на предмет наличия в нём сигнатур уже известных угроз. Сигнатурой в данном случае называется некоторая последовательность байт, необходимая и достаточная для однозначной идентификации угрозы. При этом сравнение содержимого исследуемого объекта с сигнатурами может производиться не напрямую, а по их контрольным суммам, что позволяет значительно снизить размер записей в вирусных базах, сохранив при этом однозначность соответствия и, следовательно, корректность обнаружения угроз и лечения инфицированных объектов. Следует отметить, что сигнатурное сканирование может не фиксировать наличие полиморфных вирусов, то есть вредоносных программ, которые способны формировать свой программный код «на лету», уже во время исполнения. Для обнаружения таких угроз существуют другие методы, например, эвристический, который будет рассмотрен далее;
2)        Эвристическое сканирование – метод обнаружения вирусов, нацеленный на обнаружение ранее неизвестных вирусным базам вредоносных программ.  Этот метод сканирования не обеспечивает какой-либо гарантированной защиты от новых, отсутствующих в сигнатурном наборе компьютерных вирусов, что обусловлено использованием в качестве объекта анализа сигнатур ранее известных вирусов, а в качестве правил эвристической верификации – знаний о механизме полиморфизма сигнатур. Работа данного метода основывается на наборе эвристик, то есть предположений, статистическая значимость которых подтверждена опытным путем, о характерных признаках вредоносного и, наоборот, безопасного исполняемого кода. Каждый признак имеет определенный вес, то есть число, показывающее важность и достоверность этого признака. Если признак указывает на наличие вредоносного кода, то вес оценивается как положительный, а если на наличие безопасного кода, то вес оценивается как отрицательный. На основании суммарного веса, характеризующего содержимое объекта, эвристический анализатор вычисляет вероятность содержания в нём неизвестного вредоносного объекта. Если эта вероятность превышает некоторое пороговое значение, то исследуемый объект объявляется вредоносным. Следует отметить, что поскольку этот метод базируется на некоторых эмпирических предположениях, при его использовании существует вероятность ложного срабатывания;
3)        Обнаружение аномалий – метод обнаружения вредоносных программ, основанный на выявлении необычных и подозрительных событий в наблюдаемой системе. Так, например, если программа попробует записать какие-то данные в исполняемый файл, антивирус, использующий этот метод, может отметить зафиксированное действие как небезопасное. В отличие от предыдущих методов, метод обнаружения подозрительного поведения позволяет гарантированно обнаружить совершенно новые вирусы, которых еще нет ни в одной вирусной базе. Однако этот метод также может выдавать большое количество ложных срабатываний, что делает пользователя маловосприимчивым к подобным предупреждениям;
4)        Обнаружение изменений – метод обнаружения вредоносных программ, основанный на выявлении изменений, вызываемых вирусами в системе. Работа данного метода базируется на использовании систем контроля целостности. Программы, использующие метод обнаружения изменений, периодически сканируют содержимое дисков компьютера, записывая в свою базу данных контрольные суммы файлов и критически важных внутренних областей файловых систем. При этом при сканировании новые значения контрольных сумм сравниваются со старыми значениями, и если при сравнении обнаруживаются изменения, программа сообщает об этом пользователю. Этот метод часто используют совместно с сигнатурным и эвристическим анализом, направляя антивирусную программу только на файлы и каталоги, в которых произошли изменения;
5)        Вакцинирование программ – метод обнаружения вредоносных программ, принцип работы которого заключается в присоединении к исполняемому файлу специального модуля контроля, который будет следить за целостностью этого файла. Проверке при использовании данного метода подлежат любые характеристики файла, например, его контрольная сумма. При заражении вредоносной программой вакцинированного файла модуль контроля обнаруживает изменения и сообщает об этом пользователю.

Аппаратно-программные методы основаны на реализации одного или нескольких из указанных выше методов защиты с использованием технических устройств и представляют собой один из самых надежных способов защиты программных средств от вредоносного кода. Имея полный контроль над всеми обращениями к дисковой подсистеме компьютера, аппаратно-программный комплекс при необходимости может не только сообщить о каких-либо нарушениях пользователю, но и заблокировать дальнейшую работу компьютера.

################################################################################

99.        Угрозы информационной безопасности программного обеспечения. Модели безопасности информационных систем.
Угрозами информационной безопасности называются потенциальные источники нежелательных событий, которые могут нанести ущерб ресурсам информационной системы. Безопасность ПО в широком смысле является свойством данного ПО функционировать без проявления различных негативных последствий для конкретной компьютерной системы.

Обобщенная классификация угроз информационной безопасности программного обеспечения КС может выглядеть следующим образом:
-        вредоносные программы - программы, используемые для осуществления несанкционированного доступа к информации и (или) воздействия на информацию или ресурсы автоматизированной информационной системы;
-        программные закладки - программные компоненты, заранее внедряемые в компьютерные системы, которые по сигналу или в установленное время приводятся в действие, уничтожая или искажая информацию, или дезорганизуя работу программно-технических средств;
-        способы и средства, позволяющие внедрять вредоносные программы и программные закладки в компьютерные системы и управлять ими на расстоянии.

В настоящее время одним из наиболее опасных средств информационного воздействия на компьютерные системы является использование вредоносных программ (вирусы, черви, сетевые снифферы...). В качестве основных средств вредоносного (деструктивного) воздействия на КС необходимо, наряду с вредоносными программами, рассматривать алгоритмические и программные закладки.
Алгоритмическая закладка - преднамеренное (или случайное) искажение какой-либо части алгоритма, либо построение его таким образом, что в результате конечной программной реализации этого алгоритма программа будет иметь ограничения на выполнение требуемых функций или вовсе не выполнять их при определенных условиях.
Программная закладка - совокупность операторов и (или) операндов, преднамеренно (или случайно) в завуалированной форме включаемая в состав выполняемого кода программного компонента на любом этапе его разработки. Пример: зашитые в программу учетные данные.

Действия алгоритмических и программных закладок условно можно разделить на три класса:
-        изменение функционирования вычислительной системы (сети);
-        несанкционированное считывание информации;
-        несанкционированная модификация информации, вплоть до ее уничтожения.
Указанные классы воздействий могут пересекаться.

С точки зрения времени внесения программных закладок в программы их можно разделить на две категории:
-        «врожденные», то есть закладки, внесенные при разработке ПО;
-        «приобретенные», то есть закладки, внесенные при испытаниях, эксплуатации или модернизации ПО.

--- Дальше описывается лабуда из ГОСТ Р ИСО/МЭК 15408 ---
Часть 1 "Введение и общая модель" является введением в ИСО/МЭК 15408. В ней определяются общие понятия и принципы оценки безопасности ИТ и приводится общая модель оценки.

Объект оценки - совокупность программного, программно-аппаратного и/или аппаратного обеспечения, возможно сопровождаемая руководствами.
Модель политики безопасности объекта оценки - структурированное представление политики безопасности, которая должна быть осуществлена объектом оценки.
К нарушениям безопасности обычно относят: 
-        раскрытие актива несанкционированным получателем, наносящее ущерб (потеря конфиденциальности);
-        ущерб активу вследствие несанкционированной модификации (потеря целостности);
-        несанкционированное лишение доступа к активу (потеря доступности).

Компонент - наименьшая выбираемая совокупность элементов, на которой могут основываться требования.
Семейство - совокупность компонентов, которые направлены на достижение сходной цели, но отличаются акцентами или строгостью.
Класс – совокупность семейств, объединенных общим назначением.

Компоненты считаются объединенными друг с другом комплиментарно (могут дополнять друг друга) или связью замещения (ужесточение требований безопасности, когда i-ый компонент должен включать в себя все предыдущие).
Содержание компонентов является довольно гибким за счет наличия операций: 
1) итерация: позволяет неоднократно использовать компонент при различном выполнении в нем операций;
2) назначение: позволяет определять параметры;
3) выбор: позволяет выбирать один или более пунктов из перечня;
4) уточнение: позволяет осуществлять детализацию.

Модель безопасности: 
Общие Критерии → Профиль Защиты → Задание по Безопасности

Состав профиля защиты:
1) задача по защите (среда и цели безопасности);
2) чем реализуем защиту;
3) обоснование.

Задание по безопасности: описание функций безопасности в ИС.
Создается для того, чтобы: 
1) конкретизировать функции безопасности конкретной ИС; 
2) предоставить органам аттестации и сертификации средства для проведения проверки ИС на соответствие определенным уровням безопасности.

Недостаток ОК: они направлены на описание требований безопасности информационной системы (оценку этих требований), а основной источник угроз – это сам человек.

################################################################################
100. Функциональные требования безопасности: методика формирования требований, реализация функциональных требований безопасности
Часть 2 "Функциональные компоненты безопасности" устанавливает совокупность функциональных компонентов, предназначенных для использования в качестве стандартных шаблонов, на основе которых следует устанавливать функциональные требования к ОО. ИСО/МЭК 15408-2 содержит каталог функциональных компонентов, систематизированных по семействам и классам.

В ОК представлены две различные категории требований безопасности – функциональные требования и требования доверия.
Функциональные требования безопасности – набор требований к функциям объекта информатизации, отвечающим за безопасность. Можно описать требования к самому программному продукту.
Функциональные требования налагаются на те функции ОО, которые предназначены для поддержания безопасности ИС и определяют желательный безопасный режим функционирования ОО. Функциональные требования определены в части 2 ОК. Примерами функциональных требований являются требования к идентификации, аутентификации, аудиту безопасности, неотказуемости источника (невозможности отказа от факта отправления сообщения).
Предположение безопасности – это набор условий, в котором возможно соблюдение политики безопасности.
ФБО – функции безопасности объекта. Описать в терминах РД ОК среду объекта (персонал, внешние системы, которые взаимодействуют с объектом) нельзя.
Представление класса – комментарий (для каких целей может быть использован).
Семейство конкретизирует значение отдельных функций. Дается уникальное и краткое имя (пример: FAU_GEN – семейство генерации данных аудита безопасности).
Затем определяется структура семейства. Действия по управлению определяют, каким образом можно использовать данное семейство.
Существует 11 функциональных классов:
1)        Аудит
2)        Связь
3)        Криптографическая поддержка
4)        Защита данных пользователя
5)        Идентификация и аутентификация
6)        Управление безопасностью
7)        Приватность
8)        Защита ФБО
9)        Использование ресурсов
10)        Доступ к объекту оценки
11)        Доверенный канал

################################################################################
101. Требования доверия к безопасности информационных систем: методика формирования требований, поддержание доверия к безопасности информационных систем и программных продуктов
В ОК представлены две различные категории требований безопасности – функциональные требования и требования доверия. Доверие – основа для уверенности в том, что продукт или система ИТ отвечают целям безопасности.
Основная концепция ИСО/МЭК 15408 - обеспечение доверия, основанное на оценке (активном исследовании) продукта ИТ, который должен соответствовать определенным критериям безопасности. Активное исследование – это оценка продукта или системы ИТ для определения его свойств безопасности. Оценка является традиционным способом достижения доверия, и она положена в основу ОК. Методы оценки могут, в частности, включать в себя:
а)        анализ и проверку процессов и процедур;
б)        проверку, что процессы и процедуры действительно применяются;
в)        анализ соответствия между представлениями проекта ОО;
г)        анализ соответствия каждого представления проекта ОО требованиям;
д)        верификацию доказательств;
е)        анализ руководств;
ж)        анализ разработанных функциональных тестов и полученных результатов;
и)        независимое функциональное тестирование;
к)        анализ уязвимостей, включающий предположения о недостатках;
л)        тестирование проникновения.

Классы доверия:
1)        Управление конфигурацией (помогает обеспечить сохранение целостности ОО)
2)        Поставка и эксплуатация (определяет требования к мерам, процедурам и стандартам, применяемым для безопасной поставки, установки и эксплуатации ОО, обеспечивая, чтобы безопасность ОО не нарушалась во время его распространения, установки и эксплуатации)
3)        Разработка (определяет требования для пошагового уточнения ФБО, вплоть до фактической реализации)
4)        Руководства (определяет требования, направленные на обеспечение понятности, достаточности и законченности эксплуатационной документации)
5)        Поддержка жизненного цикла (определяет требования доверия посредством принятия для всех этапов разработки ОО четко определенной модели жизненного цикла, включая политики и процедуры устранения недостатков, правильное использование инструментальных средств и методов, а также меры безопасности для защиты среды разработки)
6)        Тестирование (устанавливает требования к тестированию)
7)        Оценка уязвимостей (определяет требования, направленные на идентификацию уязвимостей, которые могут быть активизированы)

Если объект оценки имеет функции безопасности, которые реализуются вероятностными или перестановочными механизмами (такими, как пароль или хэш-функция), то требования доверия могут определять, что заявленный минимальный уровень стойкости согласуется с целями безопасности. От каждой такой функции потребуется соответствие указанному минимальному уровню стойкости или, по меньшей мере, дополнительно определенной специальной метрике.
Степень доверия для заданной совокупности функциональных требований может меняться; это, как правило, выражается через возрастание уровня строгости, задаваемого компонентами доверия. Часть 3 ОК определяет требования доверия и шкалу оценочных уровней доверия, формируемых с использованием этих компонентов. Требования доверия налагаются на действия разработчика, представленные свидетельства и действия оценщика. Примерами требований доверия являются требования к строгости процесса разработки, по поиску потенциальных уязвимостей и анализу их влияния на безопасность.

Иерархическая структура представления требований доверия (класс - семейство - компонент - элемент):
Требования доверия
        - Классы доверия
                - Имя класса
                - Представление класса
                - Семейства доверия
                        - Имя семейства
                        - Цели
                        - Ранжирование компонентов
                        - Замечения по применению
                        - Компоненты доверия
                                - Идентификация компонента
                                - Цели
                                - Замечания по применению
                                - Зависимости
                                - Элементы доверия

################################################################################

120. Методы и средства защиты информации в локальных вычислительных сетях от атак канального уровня
Для описания методов и средств защиты информации рассмотрим наиболее распространенные атаки канального уровня:
1)        ARP-spoofing (ARP-poisoning)
Address Resolution Protocol (ARP) – протокол канального уровня, использующийся для установления соответствия между IP-адресом и MAC-адресом машины. Для определения MAC-адреса получателя по IP-адресу хост формирует широковещательный Ethernet-кадр, содержащий ARP-запрос (ARP-Request). Запрос содержит MAC и IP отправителя и IP получателя. Хост, обнаруживший свой IP в поле "сетевой адрес получателя", дописывает свой MAC-адрес и отправляет ARP-ответ (ARP-Reply). Получив искомый MAC-адрес, хост заносит его в ARP-кэш, и в дальнейшем для отправки запросов пользуется полученным адресом.
Недостатком данного протокола является отсутствие проверки подлинности пакетов: как запросов, так и ответов. Злоумышленник, отправляя ARP-ответы без предварительного ARP-запроса, может подменить содержимое ARP-кэша произвольным образом и перехватывать трафик между узлами в пределах одного широковещательного домена.
Способы защиты от атаки ARP-spoofing:
−        использовать статическую ARP-таблицу. Необходимые соответствия адресов добавляются в ARP-таблицу и в дальнейшем не заменяются;
−        использовать VLAN. В случае, когда машины злоумышленника и жертвы будут расположены в разных виртуальных сетях, атака не будет возможна;
−        использовать Packet Filtering ACL на коммутаторах. Например, современные коммутаторы DLINK и CISCO поддерживают инструменты анализа пакетов и фильтрацию по конкретным параметрам. Первый вариант: фильтрация всех ARP-пакетов на всех пользовательских портах, у которых в Sender Protocol Address содержится IP-адрес шлюза, что позволяет защититься от подмены адреса шлюза. Второй вариант: фильтрация всех ARP-пакетов на каждом из пользовательских портов, у которых Sender Hardware Address и Sender Protocol Address отличаются уже известных MAC и IP-адресов, что позволяет защититься еще и от подмены адреса некоторого пользователя.
2)        Атаки MAC-spoofing, MAC-flooding
MAC-spoofing – атака канального уровня, суть которой заключается в изменении MAC-адреса сетевого устройства. Благодаря этому коммутатор начинает отправлять на порт, к которому подключен злоумышленник, пакеты, которые он до этого видеть не мог.
MAC-flooding (переполнение таблицы коммутации) – атака, основанная на том, что таблица коммутации в коммутаторах имеет ограниченный размер. После заполнения таблицы, коммутатор не может более запоминать новые MAC-адреса и начинает отправлять трафик на все порты.
Для защиты от этих атак можно использовать функцию коммутатора Port Security: она позволяет указать список MAC-адресов, которым разрешено передавать данные через порт, и дополнительно позволяет ограничить количество подключений на интерфейсе.
3)        Атаки на DHCP-сервер
К основным атакам этого класса относятся:
−        DoS DHCP-сервера. Злоумышленник может сформировать и послать DHCP-серверу огромное количество DHCP-запросов с разными MAC-адресами. Сервер будет выделять IP-адреса из пула, который через некоторое время закончится, после чего DHCP-сервер не сможет обслуживать новых клиентов. Для защиты от этой атаки используется метод DHCP Snooping, который заключается в сравнении MAC-адреса, указанного в DHCP-запросе, с MAC-адресом, который прописан на порту коммутатора. Если адреса не совпадают – пакет отбрасывается, иначе принимается;
−        «Ложный» DHCP-сервер. Злоумышленник может развернуть свой DHCP-сервер и выдавать свои настройки пользователям сети, обеспечивая себе возможность прослушивания трафика, подделки DNS-ответов и т.д.. Для этого необходимо предварительно вывести из строя легальный DHCP-сервер (например, с помощью DoS), следовательно, защита от атаки будет происходить аналогичным образом.
4)        Атака VLAN hopping
VLAN – виртуальная сеть, хосты в которой взаимодействуют друг с другом так, как если бы они были подключены к одному широковещательному домену, независимо от их физического местоположения. Порты коммутаторов, принадлежащие одной VLAN, могут обмениваться кадрами между собой, но не могут обмениваться кадрами с портами других VLAN. При этом порты, предназначенные для передачи кадров только одной виртуальной сети, называются портами доступа, а порты, предназначенные для передачи кадров нескольких VLAN – магистральными, или «транковыми».
VLAN hopping – общее название для атак, которые предполагают проникновение в VLAN, который до выполнения атаки не был доступен атакующему.
Основной атакой этого класса является атака с использованием Dynamic Trunking Protocol (DTP), когда злоумышленник через свой порт отправляет пакет DTP, в результате чего коммутатор считает этот порт магистральным.
Для создания ЛВС, защищенных от атак этого класса, используются следующие принципы:
−        запретить передачу кадров собственной VLAN по магистральным каналам, а в качестве native VLAN использовать VLAN, специально выделенную для этих целей;
−        не использовать стандартную VLAN 1, особенно для управления сетевым оборудованием;
−        на магистральных портах использовать только необходимые VLAN – VLAN, все прочие запрещать;
−        не использовать одинаковые VLAN на разных коммутаторах;
−        все неиспользуемые порты коммутатора переводить в режим shutdown и определять их в отдельную изолированную VLAN.
5)        Атаки на STP
Протокол Spanning Tree Protocol (STP) предназначен для предотвращения зацикливания пакетов  сети при наличии дублирующих маршрутов. Для этого сначала производится обнаружение коммутаторов, которые связаны между собой. Далее среди них выбирается главный, корневой коммутатор (root bridge), после чего блокируются порты коммутатора, которые создают петли в получившейся топологии.
Для построения древовидной структуры без петель в сети должен быть определен корневой коммутатор, от которого и будет строиться это дерево. В качестве корневого коммутатора выбирается коммутатор с наименьшим значением идентификатора. Идентификатор – это число длиной 8 байт, 6 младших байтов которого составляет MAC-адрес его блока управления, а 2 старших байта конфигурируются вручную, что позволяет администратору сети влиять на процесс выбора корневого коммутатора. Если администратор не вмешается в данный процесс, в качестве корневого будет выбран коммутатор с наименьшим MAC-адресом блока управления. Такой выбор может быть далеко не рациональным, поэтому рекомендуется выбирать корневой коммутатор исходя из топологии сети и назначать ему наименьший идентификатор вручную. Далее для каждого коммутатора определяется корневой порт (root port) – порт, который имеет кратчайшее расстояние до корневого коммутатора. Для каждого логического сегмента сети выбирается назначенный мост (designated bridge), один из портов которого будет принимать пакеты от сегмента и передавать их в направлении корневого коммутатора через корневой порт данного моста.
В процессе атаки злоумышленник может притвориться коммутатором так же, как и в атаке VLAN hopping, и направить в сторону атакуемого коммутатора BDPU-пакет с подделанным приоритетом и MAC-адресом, чтобы в результате самому стать корневым коммутатором и с его помощью перехватывать сетевой трафик.
Для защиты от атак этого класса используются следующие принципы:
−        использовать протоколы семейства STP с целью построения отказоустойчивых ЛВС только при необходимости. По возможности использовать механизмы и протоколы маршрутизации сетевого уровня;
−        административно определять и назначать корневые коммутаторы. Использовать дополнительные механизмы и средства защиты протокола STP (RootGuard, LoopGuard, UplinkFast, UDLD) для предотвращения получения роли корневого коммутатора другими коммутаторами;
−        на портах доступа коммутаторов ЛВС выполнять настройки по предотвращению возможности появления или фильтрации BPDU-пакетов протокола STP (механизмы BPDU Guard и BPDU Filter соответственно), а также выполнять настройки для быстрого включения и защиты корневого коммутатора (механизмы PortFast и RootGuard соответственно).
